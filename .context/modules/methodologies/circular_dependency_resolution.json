{
  "type": "methodology_module",
  "domain": "architecture_refactoring",
  "version": "1.0.0",
  "created": "2025-10-08T00:00:00Z",
  "template_info": {
    "name": "Circular Dependency Resolution Methodology",
    "description": "Систематический подход к разрешению циклических зависимостей через архитектурный рефакторинг",
    "target_projects": [
      "C/C++ проекты с модульной архитектурой",
      "CMake-based build systems",
      "Проекты с OBJECT_LIBRARY компонентами",
      "Большие кодовые базы с legacy зависимостями"
    ],
    "applicability": "Универсален для любых проектов с циклическими зависимостями"
  },
  "navigation_system": {
    "purpose": "Методология разрешения циклических зависимостей",
    "recovery_path": ".context/manifest.json",
    "current_file": ".context/modules/methodologies/circular_dependency_resolution.json",
    "file_role": "METHODOLOGY_MODULE",
    "related_files": {
      ".context/modules/languages/c/c_development.json": "C development standards",
      ".context/modules/projects/dap_sdk.json": "DAP SDK project context"
    },
    "ai_context": "Файл СЛК системы: circular_dependency_resolution.json"
  },
  "principles": {
    "core_philosophy": "Циклические зависимости - это признак архитектурных проблем, требующих глубокого рефакторинга, а не быстрых обходных решений",
    "fundamental_rules": [
      "НИКОГДА не использовать forward declarations как решение",
      "НИКОГДА не добавлять include paths для обхода циклов",
      "НИКОГДА не создавать симлинки",
      "НИКОГДА не копировать код между модулями",
      "НИКОГДА не использовать условную компиляцию (#ifdef) для скрытия проблем",
      "ВСЕГДА выбирать путь глубокого архитектурного рефакторинга"
    ],
    "when_to_refactor": {
      "immediate": "Если CMake выдаёт ошибку циклических зависимостей для OBJECT_LIBRARY",
      "planned": "Если обнаружены циклы в header файлах, даже если CMake пока компилируется",
      "proactive": "Если модуль зависит от слишком многих других модулей (>5-7 прямых зависимостей)"
    }
  },
  "analysis_framework": {
    "step_1_identify_cycles": {
      "description": "Идентификация всех циклов в системе",
      "methods": [
        "CMake error messages - прямое указание на циклы",
        "Анализ target_link_libraries в CMakeLists.txt",
        "Проверка #include директив в заголовочных файлах",
        "cmake --graphviz=deps.dot для визуализации"
      ],
      "tools": [
        "grep -r 'target_link_libraries' */CMakeLists.txt",
        "grep -r '#include \"dap_' module/*/include/*.h",
        "cmake --graphviz=deps.dot . && dot -Tpng deps.dot -o deps.png"
      ],
      "output": "Список всех циклов с точными путями зависимостей"
    },
    "step_2_analyze_usage": {
      "description": "Детальный анализ того, КАК используются зависимости",
      "questions_to_answer": [
        "Какие конкретно типы/функции/макросы используются?",
        "Используется ли полное определение типа или достаточно forward declaration?",
        "Можно ли вынести используемые элементы в общий модуль?",
        "Можно ли инвертировать зависимость через callbacks?",
        "Сколько точек использования в коде?"
      ],
      "methods": [
        "grep для поиска использования типов",
        "codebase_search для понимания контекста использования",
        "Чтение .c файлов для понимания реального использования (не только headers)"
      ],
      "output": "Подробная карта использования для каждой зависимости"
    },
    "step_3_count_dependencies": {
      "description": "Подсчёт зависимостей каждого модуля",
      "algorithm": "Для каждого модуля в цикле - подсчитать ВХОДЯЩИЕ и ИСХОДЯЩИЕ зависимости",
      "selection_criteria": "Выбрать модуль с НАИМЕНЬШИМ количеством зависимостей для начала рефакторинга",
      "rationale": "Проще всего рефакторить модуль с минимальными зависимостями",
      "output": "Ранжированный список модулей от меньшего к большему по количеству зависимостей"
    },
    "step_4_identify_hotspots": {
      "description": "Определение концентрации зависимостей",
      "questions": [
        "Где сосредоточены зависимости? В одном .c файле или распределены?",
        "Кто ещё зависит от этих же типов/функций?",
        "Можно ли переместить эти объекты в другой модуль?",
        "Есть ли общий паттерн использования?"
      ],
      "output": "Список кандидатов на вынос в общий модуль или на callback-инверсию"
    },
    "step_5_evaluate_solutions": {
      "description": "Оценка возможных решений",
      "solution_types": {
        "type_extraction": {
          "name": "Вынос общих типов",
          "when_applicable": "Если несколько модулей используют одни и те же базовые типы",
          "implementation": "Создать модуль lower-level (напр. net_common) и перенести типы туда",
          "complexity": "MEDIUM",
          "cleanliness": "HIGH"
        },
        "callback_inversion": {
          "name": "Инверсия зависимостей через callbacks",
          "when_applicable": "Если модуль A вызывает функции модуля B для уведомлений",
          "implementation": "Модуль B регистрирует callbacks в модуле A (или в общем модуле)",
          "complexity": "MEDIUM-HIGH",
          "cleanliness": "VERY HIGH",
          "examples": [
            "stream уведомляет link_manager → callbacks в net_common",
            "json_rpc регистрирует обработчики в cli_server"
          ]
        },
        "interface_abstraction": {
          "name": "Слой абстракции с интерфейсами",
          "when_applicable": "Если модуль хранит указатели на объекты другого модуля",
          "implementation": "Создать абстрактный интерфейс с vtable callbacks",
          "complexity": "HIGH",
          "cleanliness": "VERY HIGH",
          "examples": [
            "link_manager хранит dap_client_t* → создать link_client_interface"
          ]
        },
        "module_decomposition": {
          "name": "Декомпозиция модуля",
          "when_applicable": "Если модуль имеет слишком много ответственностей",
          "implementation": "Разделить модуль на core и extensions",
          "complexity": "VERY HIGH",
          "cleanliness": "VERY HIGH",
          "examples": [
            "global_db → global_db_storage + cluster_manager"
          ]
        }
      },
      "selection_criteria": [
        "Чистота кода (cleanliness) - приоритет №1",
        "Универсальность решения - можно ли использовать в других местах?",
        "Минимизация breaking changes в публичном API",
        "Трудозатраты - только если cleanliness одинаковая"
      ]
    }
  },
  "resolution_strategies": {
    "strategy_1_type_extraction": {
      "name": "Extraction of Common Types",
      "description": "Вынос общих типов данных в low-level модуль",
      "steps": [
        {
          "step": 1,
          "action": "Создать новый low-level модуль (напр. module/common или module/net/common)",
          "details": "Этот модуль НЕ должен зависеть от high-level модулей"
        },
        {
          "step": 2,
          "action": "Перенести общие типы данных в новый модуль",
          "details": "Типы, структуры, enum, макросы, используемые несколькими модулями"
        },
        {
          "step": 3,
          "action": "Обновить include директивы",
          "details": "Заменить старые #include на новый модуль"
        },
        {
          "step": 4,
          "action": "Обновить CMakeLists.txt",
          "details": "Добавить зависимость от нового модуля"
        },
        {
          "step": 5,
          "action": "Убедиться что цикл разорван",
          "details": "cmake --graphviz для проверки"
        }
      ],
      "example": {
        "problem": "stream.h includes client.h, client.h includes stream.h",
        "solution": "Create net_common module with dap_stream_node_addr_t",
        "result": "Both stream and client depend on net_common (no cycle)"
      }
    },
    "strategy_2_callback_inversion": {
      "name": "Dependency Inversion via Callbacks",
      "description": "Инверсия зависимостей через систему callbacks",
      "principle": "Dependency Inversion Principle (DIP) - high-level модули не зависят от low-level, оба зависят от абстракций",
      "steps": [
        {
          "step": 1,
          "action": "Определить направление зависимости",
          "details": "Кто кого уведомляет? A уведомляет B → B должен регистрировать callback в A"
        },
        {
          "step": 2,
          "action": "Создать callback типы в common модуле",
          "details": "typedef void (*module_event_callback_t)(params..., void *user_data);"
        },
        {
          "step": 3,
          "action": "Реализовать регистрацию и вызов callbacks",
          "details": "Функции register/unregister и notify в common модуле или в источнике событий"
        },
        {
          "step": 4,
          "action": "Заменить прямые вызовы на callbacks",
          "details": "Вместо direct_function_call() → callback_notify()"
        },
        {
          "step": 5,
          "action": "Регистрировать callbacks при инициализации",
          "details": "В _init() функциях модулей"
        }
      ],
      "example": {
        "problem": "stream calls dap_link_manager_stream_add() directly",
        "solution": "Create dap_stream_event_callbacks in net_common, stream calls dap_stream_event_notify_add(), link_manager registers callback",
        "result": "stream depends only on net_common (no cycle)"
      },
      "thread_safety": "ОБЯЗАТЕЛЬНО использовать pthread_rwlock для защиты callback регистрации/вызовов"
    },
    "strategy_3_interface_abstraction": {
      "name": "Interface Abstraction Layer",
      "description": "Создание абстрактного интерфейса для развязки конкретных реализаций",
      "when_to_use": "Когда модуль хранит указатели на объекты другого модуля и работает с ними",
      "steps": [
        {
          "step": 1,
          "action": "Создать интерфейсный модуль",
          "details": "module/[domain]_interface/ с callback-based интерфейсом"
        },
        {
          "step": 2,
          "action": "Определить vtable структуру",
          "details": "typedef struct callbacks { void* (*create)(); int (*method)(); ... }"
        },
        {
          "step": 3,
          "action": "Создать wrapper структуру",
          "details": "typedef struct interface { void *instance; callbacks_t *vtable; }"
        },
        {
          "step": 4,
          "action": "Реализовать адаптеры",
          "details": "Конкретная реализация → интерфейс (напр. dap_client → link_client_interface)"
        },
        {
          "step": 5,
          "action": "Рефакторить потребителя",
          "details": "Заменить конкретные типы на интерфейсы во всех местах использования"
        }
      ],
      "example": {
        "problem": "link_manager has dap_client_t *client field, requires full client definition",
        "solution": "Create dap_link_client_interface with opaque pointer + vtable, link_manager stores interface instead of dap_client_t",
        "result": "link_manager depends on interface (low-level), client implements interface (no cycle)"
      }
    },
    "strategy_4_module_decomposition": {
      "name": "Module Decomposition",
      "description": "Разделение монолитного модуля на core и extensions",
      "when_to_use": "Когда модуль имеет множественные ответственности (Single Responsibility Principle violation)",
      "steps": [
        {
          "step": 1,
          "action": "Идентифицировать ответственности модуля",
          "details": "Что делает модуль? Можно ли выделить independent части?"
        },
        {
          "step": 2,
          "action": "Выделить core функциональность",
          "details": "Основная ответственность модуля без зависимостей на other high-level модули"
        },
        {
          "step": 3,
          "action": "Создать extension модули",
          "details": "Дополнительная функциональность, которая МОЖЕТ зависеть от high-level модулей"
        },
        {
          "step": 4,
          "action": "Рефакторить API",
          "details": "Core модуль с минимальным API, extensions добавляют функциональность"
        },
        {
          "step": 5,
          "action": "Обновить все использования",
          "details": "Потребители теперь зависят от core или extensions в зависимости от needs"
        }
      ],
      "example": {
        "problem": "global_db does both storage AND cluster communication (depends on stream)",
        "solution": "Split into global_db_storage (core, no stream dep) + cluster_manager (extension, CAN depend on stream)",
        "result": "global_db_storage is low-level (no cycles), cluster_manager is high-level consumer"
      }
    }
  },
  "analysis_checklist": {
    "dependency_mapping": {
      "task": "Создать полную карту зависимостей",
      "commands": [
        "grep -r 'target_link_libraries' module/*/CMakeLists.txt | grep MODULE_NAME",
        "grep -r '#include \"dap_' module/MODULE_NAME/include/*.h",
        "grep -r 'MODULE_TYPE' module/*/include/*.h"
      ],
      "output_format": {
        "cmake_deps": "Список модулей из target_link_libraries",
        "header_deps": "Список заголовков из #include",
        "usage_patterns": "Как именно используются типы/функции"
      }
    },
    "usage_analysis": {
      "task": "Понять глубину использования зависимостей",
      "checks": [
        "Хранятся ли объекты типа (field в структуре)?",
        "Используется ли sizeof для типа?",
        "Вызываются ли функции напрямую?",
        "Используются ли только указатели (opaque pointers)?",
        "Используются ли макросы/enum?"
      ],
      "classification": {
        "shallow": "Только указатели, можно forward declaration",
        "medium": "Функции API, можно callback inversion",
        "deep": "sizeof, fields access - нужен полный тип или refactoring"
      }
    },
    "count_dependencies": {
      "task": "Ранжировать модули по количеству зависимостей",
      "metrics": {
        "incoming": "Сколько модулей зависят ОТ этого модуля",
        "outgoing": "От скольких модулей зависит ЭТОТ модуль",
        "total": "incoming + outgoing"
      },
      "strategy": "Начинать рефакторинг с модулей с наименьшим outgoing (меньше работы)"
    }
  },
  "solution_patterns": {
    "pattern_1_common_module": {
      "name": "Common Module Pattern",
      "structure": "module/common/ или module/DOMAIN/common/",
      "contents": [
        "Базовые типы данных (structs, unions, enums)",
        "Общие макросы и константы",
        "Утилитные функции без зависимостей",
        "Forward declarations для high-level типов"
      ],
      "rules": [
        "Common модуль НЕ ДОЛЖЕН зависеть от high-level модулей",
        "Только базовые зависимости: core, io, crypto (базовые)",
        "Минимальная логика - в основном типы и простые утилиты"
      ],
      "dap_sdk_example": {
        "module": "module/net/common/",
        "contents": [
          "dap_stream_node_addr_t - базовый сетевой тип",
          "Cluster type enums",
          "Callback typedefs для инверсии зависимостей",
          "Node address utility functions"
        ],
        "breaks_cycles": [
          "stream ↔ cluster",
          "global_db ↔ types"
        ]
      }
    },
    "pattern_2_callback_registry": {
      "name": "Callback Registry Pattern",
      "description": "Централизованная регистрация callbacks для разрыва циклов уведомлений",
      "components": {
        "callback_types": "typedef void (*event_callback_t)(params..., void *user_data);",
        "registry": "Static variables + rwlock для thread-safety",
        "registration_api": "int module_event_register(callback_t cb, void *data);",
        "notification_api": "void module_event_notify(params...);"
      },
      "thread_safety": "ОБЯЗАТЕЛЬНО pthread_rwlock_t для защиты регистрации/вызовов",
      "location_options": {
        "option_1": "В common модуле - если callbacks используются multiple модулями",
        "option_2": "В source модуле (генераторе событий) - если callbacks только для одной пары модулей"
      },
      "dap_sdk_examples": {
        "stream_events": {
          "location": "dap_net_common",
          "callbacks": [
            "dap_stream_event_add_callback_t",
            "dap_stream_event_replace_callback_t",
            "dap_stream_event_delete_callback_t"
          ],
          "registrant": "link_manager registers callbacks",
          "notifier": "stream calls dap_stream_event_notify_*()",
          "breaks_cycle": "stream → link_manager"
        },
        "json_rpc_handlers": {
          "location": "dap_json_rpc",
          "callbacks": [
            "dap_json_rpc_method_handler_t",
            "dap_json_rpc_url_handler_t"
          ],
          "registrant": "cli_server (and others) register handlers",
          "notifier": "json_rpc calls registered handlers",
          "breaks_cycle": "json_rpc → cli_server"
        }
      }
    },
    "pattern_3_interface_vtable": {
      "name": "Interface with VTable Pattern",
      "description": "OOP-style интерфейсы в C через vtable",
      "structure": {
        "interface_header": "include/module_interface.h",
        "interface_impl": "module_interface.c (registration/management)",
        "adapter_impl": "В конкретном модуле - реализация интерфейса"
      },
      "code_template": {
        "interface_definition": "typedef struct module_interface {\n    void *instance;\n    struct module_callbacks *vtable;\n} module_interface_t;",
        "callbacks_definition": "typedef struct module_callbacks {\n    int (*method1)(void *instance, params...);\n    void (*method2)(void *instance, params...);\n    void (*destroy)(void *instance);\n} module_callbacks_t;",
        "adapter_implementation": "static module_callbacks_t s_concrete_vtable = {\n    .method1 = concrete_method1_adapter,\n    .method2 = concrete_method2_adapter,\n    .destroy = concrete_destroy_adapter\n};\n\nmodule_interface_t* concrete_to_interface(concrete_t *obj) {\n    module_interface_t *iface = DAP_NEW(module_interface_t);\n    iface->instance = obj;\n    iface->vtable = &s_concrete_vtable;\n    return iface;\n}"
      },
      "benefits": [
        "Полное разделение интерфейса и реализации",
        "Легко тестировать через mock implementations",
        "Можно подменять реализации в runtime",
        "Универсальный - другие модули тоже могут реализовать интерфейс"
      ]
    }
  },
  "forbidden_solutions": {
    "forward_declarations_only": {
      "why_forbidden": "Скрывает проблему, не решает. Работает только если нет sizeof/field access",
      "when_breaks": "При sizeof(type), при доступе к полям struct, при inline functions",
      "proper_solution": "Если достаточно forward - значит можно вынести тип в common. Если нет - нужен рефакторинг"
    },
    "include_path_hacks": {
      "examples": [
        "target_include_directories для обхода циклов",
        "../../../other_module/include в #include",
        "Симлинки на заголовочные файлы"
      ],
      "why_forbidden": "Маскирует циклы, создаёт хрупкие build системы, ломает модульность",
      "proper_solution": "Исправить архитектуру зависимостей, не build system"
    },
    "conditional_compilation": {
      "examples": [
        "#ifdef MODULE_AVAILABLE для скрытия зависимостей",
        "#ifndef SDK_ONLY для отключения проблемного кода",
        "Stub implementations под #ifdef"
      ],
      "why_forbidden": "Создаёт несколько версий кода, усложняет тестирование, прячет проблемы",
      "when_acceptable": "ТОЛЬКО для platform-specific кода (Windows/Linux/MacOS), НЕ для обхода циклов"
    },
    "code_duplication": {
      "examples": [
        "Копирование структур между модулями",
        "Дублирование функций чтобы избежать зависимости"
      ],
      "why_forbidden": "Maintenance nightmare, легко desync, нарушает DRY",
      "proper_solution": "Вынести в common модуль и оба зависят от common"
    }
  },
  "implementation_guidelines": {
    "callback_implementation": {
      "thread_safety_requirements": {
        "lock_type": "pthread_rwlock_t (читателей много, писателей мало)",
        "read_operations": "pthread_rwlock_rdlock для вызова callbacks",
        "write_operations": "pthread_rwlock_wrlock для регистрации/разрегистрации",
        "initialization": "PTHREAD_RWLOCK_INITIALIZER для static initialization"
      },
      "null_safety": {
        "always_check": "if (callback) callback(params); перед вызовом",
        "user_data": "void *user_data ВСЕГДА последний параметр callback",
        "optional_callbacks": "Система должна работать даже если callbacks не зарегистрированы"
      },
      "error_handling": {
        "registration": "Возвращать 0 на success, negative on error",
        "logging": "log_it(L_WARNING) если callback уже зарегистрирован (replacement)",
        "unregistration": "void функция - всегда успешна"
      }
    },
    "common_module_organization": {
      "file_structure": {
        "header": "include/dap_MODULE_common.h - типы, макросы, callback typedefs, API declarations",
        "source": "dap_MODULE_common.c - callback registry implementation, utility functions"
      },
      "content_guidelines": {
        "types": "Только фундаментальные типы, используемые 3+ модулями",
        "macros": "Utility macros без внешних зависимостей",
        "functions": "Простые утилиты (parsing, conversion, comparison)",
        "callbacks": "Callback typedefs и registry для инверсии зависимостей"
      },
      "dependencies": {
        "allowed": [
          "dap_core (dap_common.h, log_it)",
          "system headers (stdint.h, pthread.h)",
          "dap_config (для custom parsers)"
        ],
        "forbidden": [
          "Любые high-level модули (stream, client, server, etc)",
          "Специфичная бизнес-логика",
          "Тяжёлые зависимости"
        ]
      }
    },
    "cmake_best_practices": {
      "library_type": "dap_add_library для консистентности с остальными модулями",
      "linking": "PUBLIC для dependencies, PRIVATE для implementation-only",
      "include_dirs": "PUBLIC include/ для экспорта заголовков",
      "comments": "Документировать причины зависимостей и TODO для будущего рефакторинга"
    }
  },
  "case_study_dap_sdk": {
    "description": "Реальные примеры разрешения циклов в DAP SDK",
    "cycle_1_json_rpc_cli_server": {
      "original_cycle": "cli_server → json_rpc → cli_server",
      "analysis": {
        "problem": "json_rpc парсил запросы и вызывал dap_cli_cmd_exec() напрямую",
        "dependency_direction": "json_rpc уведомлял cli_server о командах",
        "usage_pattern": "Callback notification pattern"
      },
      "solution": "Callback Registry in json_rpc",
      "implementation": {
        "callback_types": [
          "dap_json_rpc_method_handler_t",
          "dap_json_rpc_url_handler_t"
        ],
        "registration": "cli_server calls dap_json_rpc_register_method_handler()",
        "notification": "json_rpc calls registered handler when request arrives"
      },
      "result": {
        "cycle_broken": "YES - json_rpc no longer depends on cli_server",
        "code_quality": "VERY HIGH - universal handler system",
        "additional_benefits": "Other modules can also register handlers"
      }
    },
    "cycle_2_stream_link_manager": {
      "original_cycle": "stream → link_manager → client → stream",
      "analysis": {
        "problem": "stream вызывал dap_link_manager_stream_add() напрямую для уведомления о новых streams",
        "dependency_direction": "stream уведомлял link_manager о lifecycle событиях",
        "usage_pattern": "Event notification pattern"
      },
      "solution": "Callback Registry in net_common",
      "implementation": {
        "callback_types": [
          "dap_stream_event_add_callback_t",
          "dap_stream_event_replace_callback_t",
          "dap_stream_event_delete_callback_t"
        ],
        "registration": "link_manager calls dap_stream_event_callbacks_register() in init",
        "notification": "stream calls dap_stream_event_notify_add() instead of direct dap_link_manager_stream_add()"
      },
      "result": {
        "cycle_broken": "YES - stream no longer depends on link_manager",
        "code_quality": "VERY HIGH - universal event system",
        "location": "net_common (shared между stream и link_manager)"
      }
    },
    "cycle_3_json_rpc_client_pvt": {
      "original_cycle": "json_rpc → client → stream → json_rpc",
      "analysis": {
        "problem": "json_rpc использовал dap_client_pvt_t для encrypted requests",
        "dependency_direction": "json_rpc → client (dap_client_pvt.h)",
        "usage_pattern": "Direct usage of internal structures"
      },
      "solution": "Extract dap_client_http + use dap_enc_ks",
      "implementation": {
        "new_module": "module/net/client_http/ - standalone HTTP client",
        "encryption": "Use dap_enc_ks_find(key_id) instead of client_pvt->session_key",
        "refactored_api": "dap_json_rpc_request_send() now takes key_id parameter"
      },
      "result": {
        "cycle_broken": "YES - json_rpc depends on client_http (standalone) + enc_ks",
        "code_quality": "VERY HIGH - clean separation",
        "additional_benefits": "client_http can be used independently"
      }
    },
    "remaining_cycles": {
      "cycle_link_manager_client": {
        "status": "TODO - Phase 8.1",
        "problem": "link_manager stores dap_client_t *client pointer",
        "recommended_solution": "Interface Abstraction Layer (link_client_interface)",
        "priority": "HIGH",
        "estimated_effort": "4-6 hours"
      },
      "cycle_global_db_link_manager": {
        "status": "TODO - Phase 8.2",
        "problem": "global_db uses link_manager functions for cluster integration",
        "recommended_solution": "Module Decomposition (extract cluster_manager from global_db)",
        "priority": "MEDIUM",
        "estimated_effort": "3-4 hours"
      }
    }
  },
  "step_by_step_workflow": {
    "phase_1_analysis": {
      "duration": "30-60 minutes",
      "activities": [
        "Запустить CMake и получить список циклов",
        "Для каждого цикла - создать карту зависимостей",
        "Проанализировать код - КАК используются зависимости",
        "Подсчитать incoming/outgoing dependencies",
        "Выбрать стратегию разрешения для каждого цикла"
      ],
      "output": "Документ с детальным планом рефакторинга"
    },
    "phase_2_implementation": {
      "duration": "Variable (зависит от стратегии)",
      "sequence": [
        "Начать с самого простого цикла (наименьшие зависимости)",
        "Создать необходимые модули/интерфейсы",
        "Реализовать callbacks/abstractions",
        "Рефакторить использующий код",
        "Обновить CMakeLists.txt",
        "Проверить что цикл разорван (cmake без ошибок)",
        "Проверить компиляцию",
        "Повторить для следующего цикла"
      ],
      "git_workflow": {
        "commits": "Один коммит на один разорванный цикл",
        "commit_message_format": "refactor(MODULE): break CYCLE dependency\n\n- Strategy used\n- Changes made\n- Cycles broken\n\nFixes: #ISSUE"
      }
    },
    "phase_3_verification": {
      "duration": "30-60 minutes",
      "checks": [
        "CMake configuration без ошибок циклов",
        "Полная сборка successful",
        "Все тесты проходят",
        "cmake --graphviz - визуальная проверка DAG",
        "Code review - нет хаков/обходных путей"
      ],
      "success_criteria": "Чистый ацикличный граф зависимостей без compromise на качестве кода"
    }
  },
  "tools_and_commands": {
    "dependency_analysis": {
      "cmake_graphviz": {
        "command": "cmake --graphviz=deps.dot .",
        "visualize": "dot -Tpng deps.dot -o deps.png",
        "description": "Генерация графа зависимостей"
      },
      "grep_dependencies": {
        "cmake_links": "grep -r 'target_link_libraries' */CMakeLists.txt",
        "header_includes": "grep -r '#include \"dap_' module/*/include/*.h",
        "usage_search": "grep -r 'TYPE_NAME\\|function_name' module/"
      },
      "codebase_search": {
        "purpose": "Понять контекст использования",
        "queries": [
          "How does MODULE_A use MODULE_B?",
          "Where is TYPE_NAME used in MODULE?",
          "What functions from MODULE are called?"
        ]
      }
    },
    "verification_tools": {
      "cmake_clean_build": "rm -rf build && mkdir build && cd build && cmake ..",
      "dependency_graph": "cmake --graphviz=deps.dot . && dot -Tpng deps.dot -o deps.png",
      "compile_check": "make -j$(nproc) 2>&1 | tee build.log",
      "test_run": "ctest -j$(nproc) --output-on-failure"
    }
  },
  "quality_checklist": {
    "architecture": [
      "✓ Граф зависимостей является DAG (направленный ацикличный граф)",
      "✓ Low-level модули не зависят от high-level",
      "✓ Общие типы в common modules",
      "✓ Callbacks для event notifications"
    ],
    "code_quality": [
      "✓ Нет forward declarations как основного решения",
      "✓ Нет #ifdef для скрытия проблем",
      "✓ Нет дублирования кода",
      "✓ Нет include path хаков",
      "✓ Thread-safe callback registries"
    ],
    "maintainability": [
      "✓ Чистая архитектура без workarounds",
      "✓ Документированные причины выбора стратегий",
      "✓ TODO комментарии для будущих улучшений",
      "✓ Понятные имена модулей и интерфейсов"
    ]
  },
  "lessons_learned": {
    "dap_sdk_insights": [
      "Common modules (net_common) критически важны для large codebases",
      "Callback inversion эффективнее чем interface abstraction для simple notifications",
      "Module decomposition оправдан когда модуль имеет >1 ответственности",
      "Всегда начинать с анализа, не с кодирования",
      "Трудозатраты на правильный рефакторинг окупаются чистотой кода"
    ],
    "common_mistakes": [
      "Попытка решить быстро через forward declarations",
      "Добавление зависимости без анализа (создание новых циклов)",
      "Рефакторинг без понимания полной картины зависимостей",
      "Изменение только CMakeLists без изменения кода"
    ]
  },
  "integration_with_slc": {
    "auto_load_triggers": [
      "circular dependency",
      "циклические зависимости",
      "cmake cycle error",
      "refactoring dependencies",
      "break dependency cycle"
    ],
    "related_modules": [
      "modules/languages/c/c_development.json - C coding standards",
      "modules/projects/dap_sdk.json - DAP SDK specific context",
      "modules/methodologies/deep_refactoring.json - Deep refactoring approaches"
    ],
    "suggested_commands": [
      "./slc load-context 'circular dependency resolution'",
      "./slc intelligent-recommend 'break dependency cycle'"
    ]
  },
  "success_stories": {
    "dap_json_rpc_refactoring": {
      "date": "2025-10-07",
      "cycles_broken": 3,
      "strategies_used": [
        "Callback Registry (json_rpc handlers)",
        "Module Extraction (client_http)",
        "Type Extraction (enc_ks instead of client_pvt)"
      ],
      "lines_changed": "+2001 lines",
      "result": "Complete elimination of json_rpc cycles, clean architecture"
    },
    "stream_link_manager_refactoring": {
      "date": "2025-10-08",
      "cycles_broken": 1,
      "strategies_used": [
        "Callback Registry in net_common (stream event callbacks)"
      ],
      "result": "stream no longer depends on link_manager, universal event system"
    }
  },
  "anti_patterns_to_avoid": {
    "quick_fix_syndrome": {
      "symptom": "Желание быстро добавить forward declaration или #ifdef",
      "why_bad": "Создаёт technical debt, проблема остаётся",
      "cure": "Потратить время на анализ и правильное решение"
    },
    "dependency_explosion": {
      "symptom": "Модуль зависит от 10+ других модулей",
      "why_bad": "Tight coupling, сложно тестировать, circular dependencies inevitable",
      "cure": "Module decomposition, dependency injection, common modules"
    },
    "god_module": {
      "symptom": "Модуль делает слишком много (storage + communication + business logic)",
      "why_bad": "Single Responsibility Principle violation, dependencies на всё",
      "cure": "Decompose в core + extensions по ответственностям"
    }
  },
  "metrics_and_goals": {
    "dependency_health_metrics": {
      "modules_with_no_outgoing": "Низкоуровневые модули (core, common, crypto) - хорошо",
      "modules_with_1_3_outgoing": "Нормально - focused modules",
      "modules_with_4_7_outgoing": "Внимание - potential refactoring candidate",
      "modules_with_8_plus_outgoing": "КРИТИЧНО - обязательный рефакторинг"
    },
    "cycle_resolution_goals": {
      "primary": "Zero циклических зависимостей в production code",
      "secondary": "Минимальное количество зависимостей на модуль (<= 5)",
      "tertiary": "Чистая layered architecture (low-level ← high-level, no reverse)"
    }
  },
  "template_usage": {
    "when_to_apply": "При обнаружении циклических зависимостей в любом проекте",
    "how_to_customize": [
      "Адаптировать названия модулей под свой проект",
      "Выбрать подходящую стратегию из 4 основных",
      "Следовать step-by-step workflow",
      "Документировать решения в коде"
    ],
    "expected_outcomes": [
      "Чистая архитектура без циклов",
      "Улучшенная maintainability",
      "Легче тестировать модули independently",
      "Меньше времени на сборку (better parallelization)"
    ]
  }
}


{
  "version": "1.0.0",
  "created": "2025-01-16T23:45:00Z",
  "updated": "2025-01-16T23:45:00Z",
  "navigation_system": {
    "purpose": "Правила создания Python биндингов для DAP SDK - база знаний",
    "recovery_path": ".context/manifest.json",
    "current_file": ".context/modules/languages/python/knowledge_base/dap_sdk_binding_standards.json",
    "file_role": "PYTHON_DAP_BINDING_STANDARDS",
    "related_files": {
      ".context/manifest.json": "Главный манифест системы",
      ".context/modules/languages/python/python_development.json": "Основной модуль Python разработки",
      ".context/modules/projects/dap_sdk.json": "Модуль DAP SDK проекта"
    },
    "ai_context": "База знаний: Стандарты Python биндингов для DAP SDK"
  },
  "knowledge_base": {
    "name": "DAP SDK Python Binding Standards",
    "type": "coding_standards",
    "domain": "c_python_bindings",
    "category": "languages/python/knowledge_base",
    "priority": "critical",
    "auto_include_patterns": [
      "python dap binding",
      "python c binding", 
      "dap sdk python",
      "c extension python",
      "binding standards",
      "python биндинг",
      "си биндинг",
      "стандарты биндинга"
    ]
  },
  "dap_sdk_binding_rules": {
    "memory_management": {
      "description": "Правила управления памятью в DAP SDK биндингах",
      "rules": [
        {
          "rule_id": "DAP_MEMORY_001",
          "title": "Использовать DAP память вместо stdlib",
          "mandatory": true,
          "description": "Всегда использовать DAP_NEW/DAP_DELETE вместо malloc/free",
          "good_example": "void* ptr = DAP_NEW(dap_hash_t);",
          "bad_example": "void* ptr = malloc(sizeof(dap_hash_t));",
          "rationale": "DAP SDK имеет собственную систему управления памятью с отслеживанием утечек"
        },
        {
          "rule_id": "DAP_MEMORY_002", 
          "title": "Проверка выделения памяти",
          "mandatory": true,
          "description": "Всегда проверять успешность выделения памяти",
          "good_example": "if (!ptr) { return -ENOMEM; }",
          "bad_example": "// без проверки ptr",
          "rationale": "Обязательная проверка для устойчивости системы"
        }
      ]
    },
    "function_naming": {
      "description": "Соглашения по именованию функций биндинга",
      "rules": [
        {
          "rule_id": "DAP_NAMING_001",
          "title": "Префикс dap_ для всех функций",
          "mandatory": true,
          "description": "Все экспортируемые функции должны начинаться с dap_",
          "pattern": "^dap_[a-z][a-z0-9_]*$",
          "good_example": "dap_crypto_hash_fast()",
          "bad_example": "crypto_hash_fast() или hashFast()",
          "rationale": "Единообразие API и избежание конфликтов имен"
        },
        {
          "rule_id": "DAP_NAMING_002",
          "title": "Суффикс _py для Python специфичных функций",
          "mandatory": true,
          "description": "Функции-обертки для Python должны иметь суффикс _py",
          "pattern": "^dap_[a-z][a-z0-9_]*_py$",
          "good_example": "dap_hash_fast_py()",
          "bad_example": "dap_hash_fast_python()",
          "rationale": "Различение С API и Python wrapper функций"
        }
      ]
    },
    "variable_naming": {
      "description": "Соглашения по именованию переменных",
      "rules": [
        {
          "rule_id": "DAP_VARS_001",
          "title": "Префиксы для переменных",
          "mandatory": true,
          "description": "Использовать стандартные префиксы DAP SDK",
          "prefixes": {
            "l_": "локальные переменные",
            "a_": "аргументы функции",
            "s_": "статические переменные",
            "g_": "глобальные переменные"
          },
          "good_example": "size_t l_buffer_size = 256;",
          "bad_example": "size_t bufferSize = 256;",
          "rationale": "Стандарт DAP SDK для читаемости кода"
        }
      ]
    },
    "error_handling": {
      "description": "Обработка ошибок в биндингах",
      "rules": [
        {
          "rule_id": "DAP_ERROR_001",
          "title": "Стандартные коды возврата",
          "mandatory": true,
          "description": "Использовать стандартные errno коды для ошибок",
          "success_value": 0,
          "error_codes": {
            "-ENOMEM": "недостаток памяти",
            "-EINVAL": "неверные аргументы", 
            "-ENOENT": "объект не найден",
            "-EPERM": "операция не разрешена"
          },
          "good_example": "return l_result ? 0 : -EINVAL;",
          "bad_example": "return l_result ? 1 : -1;",
          "rationale": "Совместимость с POSIX и DAP SDK стандартами"
        },
        {
          "rule_id": "DAP_ERROR_002",
          "title": "Логирование ошибок",
          "mandatory": true,
          "description": "Логировать критические ошибки через log_it()",
          "pattern": "log_it(L_ERROR, \"Error description: %s\", error_msg);",
          "levels": {
            "L_DEBUG": "отладочная информация",
            "L_INFO": "информационные сообщения",
            "L_WARNING": "предупреждения",
            "L_ERROR": "ошибки",
            "L_CRITICAL": "критические ошибки"
          },
          "good_example": "log_it(L_ERROR, \"Failed to allocate %zu bytes\", l_size);",
          "bad_example": "printf(\"Error: allocation failed\\n\");",
          "rationale": "Единая система логирования DAP SDK"
        }
      ]
    },
    "security_constraints": {
      "description": "Требования безопасности для биндингов",
      "rules": [
        {
          "rule_id": "DAP_SECURITY_001",
          "title": "Запрет использования OpenSSL",
          "mandatory": true,
          "description": "НИКОГДА не использовать OpenSSL функции - только DAP SDK крипто",
          "forbidden_includes": [
            "#include <openssl/*>",
            "#include <ssl.h>",
            "#include <crypto.h>"
          ],
          "allowed_crypto": [
            "dap_enc_*",
            "dap_hash_*",
            "dap_sign_*"
          ],
          "rationale": "DAP SDK использует пост-квантовую криптографию вместо OpenSSL"
        },
        {
          "rule_id": "DAP_SECURITY_002",
          "title": "Валидация входных данных",
          "mandatory": true,
          "description": "Всегда валидировать аргументы от Python",
          "checks": [
            "проверка на NULL указатели",
            "проверка размеров буферов",
            "проверка диапазонов значений"
          ],
          "good_example": "if (!a_data || a_size == 0) return -EINVAL;",
          "bad_example": "// без проверки аргументов",
          "rationale": "Защита от некорректных данных из Python"
        }
      ]
    },
    "python_integration": {
      "description": "Правила интеграции с Python",
      "rules": [
        {
          "rule_id": "DAP_PYTHON_001",
          "title": "Использовать ctypes совместимые типы",
          "mandatory": true,
          "description": "Функции должны использовать типы совместимые с ctypes",
          "compatible_types": {
            "int": "c_int",
            "size_t": "c_size_t", 
            "char*": "c_char_p",
            "void*": "c_void_p",
            "uint64_t": "c_uint64"
          },
          "good_example": "int dap_function(const char* a_str, size_t a_size);",
          "bad_example": "bool dap_function(std::string& str);",
          "rationale": "Прямая интеграция с Python через ctypes"
        },
        {
          "rule_id": "DAP_PYTHON_002",
          "title": "Управление жизненным циклом объектов",
          "mandatory": true,
          "description": "Python должен управлять памятью возвращаемых объектов",
          "pattern": "Python получает ownership через ctypes",
          "memory_responsibility": "Python освобождает память через DAP_DELETE",
          "good_example": "return dap_hash_copy_for_python(l_hash);",
          "bad_example": "return l_hash; // без копирования",
          "rationale": "Избежание утечек памяти между C и Python"
        }
      ]
    },
    "code_organization": {
      "description": "Организация кода биндингов",
      "rules": [
        {
          "rule_id": "DAP_ORG_001",
          "title": "Один модуль на функциональную область",
          "mandatory": true,
          "description": "Группировать функции по логическим модулям",
          "modules": {
            "python_dap_core.c": "базовые функции инициализации",
            "python_dap_crypto.c": "криптографические функции",
            "python_dap_network.c": "сетевые функции",
            "python_dap_config.c": "функции конфигурации"
          },
          "rationale": "Модульность и поддерживаемость кода"
        },
        {
          "rule_id": "DAP_ORG_002",
          "title": "Единый заголовочный файл",
          "mandatory": true,
          "description": "Все объявления в python_cellframe_common.h",
          "structure": {
            "includes": "все необходимые DAP SDK заголовки",
            "exports": "объявления всех Python функций",
            "types": "typedef для Python совместимых типов"
          },
          "good_example": "#include \"python_cellframe_common.h\"",
          "rationale": "Единая точка доступа к API биндингов"
        }
      ]
    }
  },
  "implementation_patterns": {
    "typical_function_pattern": {
      "description": "Стандартный паттерн функции биндинга",
      "template": "int dap_function_name_py(const char* a_input, size_t a_input_size, void** a_output, size_t* a_output_size) {\n    // 1. Валидация аргументов\n    if (!a_input || a_input_size == 0 || !a_output || !a_output_size) {\n        log_it(L_ERROR, \"Invalid arguments\");\n        return -EINVAL;\n    }\n    \n    // 2. Вызов DAP SDK функции\n    dap_result_t* l_result = dap_original_function(a_input, a_input_size);\n    if (!l_result) {\n        log_it(L_ERROR, \"DAP function failed\");\n        return -ENOMEM;\n    }\n    \n    // 3. Подготовка результата для Python\n    *a_output = DAP_NEW_SIZE(uint8_t, l_result->size);\n    if (!*a_output) {\n        dap_result_free(l_result);\n        return -ENOMEM;\n    }\n    \n    memcpy(*a_output, l_result->data, l_result->size);\n    *a_output_size = l_result->size;\n    \n    // 4. Очистка\n    dap_result_free(l_result);\n    return 0;\n}"
    },
    "initialization_pattern": {
      "description": "Паттерн инициализации модуля",
      "template": "int dap_module_init(void) {\n    // Инициализация DAP SDK компонентов\n    int l_ret = dap_original_module_init();\n    if (l_ret != 0) {\n        log_it(L_ERROR, \"Failed to initialize DAP module: %d\", l_ret);\n        return l_ret;\n    }\n    \n    log_it(L_INFO, \"DAP module initialized successfully\");\n    return 0;\n}"
    }
  },
  "quality_assurance": {
    "testing_requirements": [
      "Unit tests для каждой биндинг функции",
      "Integration tests с реальными DAP SDK вызовами", 
      "Memory leak detection с valgrind",
      "Python compatibility tests"
    ],
    "review_checklist": [
      "Все функции следуют соглашениям именования",
      "Валидация всех входных аргументов",
      "Правильное управление памятью",
      "Логирование ошибок",
      "Отсутствие запрещенных библиотек (OpenSSL)",
      "Документация всех функций"
    ]
  },
  "auto_include_triggers": {
    "keywords": [
      "python binding",
      "dap sdk binding", 
      "c extension",
      "ctypes",
      "python dap",
      "binding standards",
      "питон биндинг",
      "си расширение",
      "стандарты биндинга"
    ],
    "file_patterns": [
      "src/python_dap_*.c",
      "include/python_*common.h",
      "*binding*.py",
      "*extension*.c"
    ],
    "task_patterns": [
      "*биндинг*",
      "*binding*", 
      "*extension*",
      "*dap*python*"
    ]
  }
} 
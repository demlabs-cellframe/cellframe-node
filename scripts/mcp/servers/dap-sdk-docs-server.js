#!/usr/bin/env node

/**
 * DAP SDK Documentation MCP Server
 * –ü—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç –¥–æ—Å—Ç—É–ø –∫ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ DAP SDK —á–µ—Ä–µ–∑ Model Context Protocol
 */

const fs = require('fs');
const path = require('path');
const { Server } = require('@modelcontextprotocol/sdk/server/index.js');
const {
  CallToolRequestSchema,
  ErrorCode,
  ListToolsRequestSchema,
  McpError,
} = require('@modelcontextprotocol/sdk/types.js');

class DapSdkDocsServer {
  constructor() {
    this.server = new Server(
      {
        name: 'dap-sdk-docs-server',
        version: '1.0.0',
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    this.docsPath = process.env.PROJECT_ROOT || path.join(__dirname, '../../../');
    this.setupToolHandlers();
  }

  setupToolHandlers() {
    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
    this.server.setRequestHandler(ListToolsRequestSchema, async () => {
      return {
        tools: [
          {
            name: 'search_docs',
            description: '–ü–æ–∏—Å–∫ –ø–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ DAP SDK',
            inputSchema: {
              type: 'object',
              properties: {
                query: {
                  type: 'string',
                  description: '–ü–æ–∏—Å–∫–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å'
                },
                category: {
                  type: 'string',
                  enum: ['core', 'crypto', 'net', 'cellframe', 'all'],
                  description: '–ö–∞—Ç–µ–≥–æ—Ä–∏—è –ø–æ–∏—Å–∫–∞'
                }
              },
              required: ['query']
            }
          },
          {
            name: 'get_module_docs',
            description: '–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –º–æ–¥—É–ª—è',
            inputSchema: {
              type: 'object',
              properties: {
                module: {
                  type: 'string',
                  description: '–ò–º—è –º–æ–¥—É–ª—è (–Ω–∞–ø—Ä–∏–º–µ—Ä: dap_cbuf, dap_math_ops)'
                },
                category: {
                  type: 'string',
                  enum: ['core', 'crypto', 'net'],
                  default: 'core',
                  description: '–ö–∞—Ç–µ–≥–æ—Ä–∏—è –º–æ–¥—É–ª—è'
                }
              },
              required: ['module']
            }
          },
          {
            name: 'list_modules',
            description: '–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –≤—Å–µ—Ö –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–æ–¥—É–ª–µ–π',
            inputSchema: {
              type: 'object',
              properties: {
                category: {
                  type: 'string',
                  enum: ['core', 'crypto', 'net', 'cellframe', 'all'],
                  description: '–ö–∞—Ç–µ–≥–æ—Ä–∏—è –º–æ–¥—É–ª–µ–π'
                }
              }
            }
          },
          {
            name: 'get_architecture_info',
            description: '–ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–µ DAP SDK',
            inputSchema: {
              type: 'object',
              properties: {
                component: {
                  type: 'string',
                  enum: ['dap-sdk', 'cellframe-sdk', 'overview'],
                  description: '–ö–æ–º–ø–æ–Ω–µ–Ω—Ç –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã'
                }
              }
            }
          }
        ]
      };
    });

    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      const { name, arguments: args } = request.params;

      try {
        switch (name) {
          case 'search_docs':
            return await this.searchDocs(args);
          case 'get_module_docs':
            return await this.getModuleDocs(args);
          case 'list_modules':
            return await this.listModules(args);
          case 'get_architecture_info':
            return await this.getArchitectureInfo(args);
          default:
            throw new McpError(
              ErrorCode.MethodNotFound,
              `Unknown tool: ${name}`
            );
        }
      } catch (error) {
        console.error(`Error in tool ${name}:`, error);
        throw new McpError(
          ErrorCode.InternalError,
          `Internal error: ${error.message}`
        );
      }
    });
  }

  async searchDocs(args) {
    const { query, category = 'all' } = args;

    if (!query || query.trim().length === 0) {
      throw new McpError(
        ErrorCode.InvalidParams,
        'Query parameter is required and cannot be empty'
      );
    }

    const results = [];
    const searchPaths = this.getSearchPaths(category);

    for (const searchPath of searchPaths) {
      if (fs.existsSync(searchPath)) {
        const files = this.findMarkdownFiles(searchPath);

        for (const file of files) {
          const content = fs.readFileSync(file, 'utf8');
          const matches = this.searchInContent(content, query);

          if (matches.length > 0) {
            results.push({
              file: path.relative(this.docsPath, file),
              matches: matches.slice(0, 5), // –û–≥—Ä–∞–Ω–∏—á–∏—Ç—å –¥–æ 5 —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π
              module: this.extractModuleName(file)
            });
          }
        }
      }
    }

    return {
      content: [
        {
          type: 'text',
          text: `–ù–∞–π–¥–µ–Ω–æ ${results.length} —Ñ–∞–π–ª–æ–≤ —Å —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è–º–∏ –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞ "${query}":\n\n` +
                results.map(r =>
                  `üìÑ ${r.file}\n` +
                  `üì¶ –ú–æ–¥—É–ª—å: ${r.module}\n` +
                  `üîç –°–æ–≤–ø–∞–¥–µ–Ω–∏—è:\n${r.matches.map(m => `  ‚Ä¢ ${m}`).join('\n')}\n`
                ).join('\n')
        }
      ]
    };
  }

  async getModuleDocs(args) {
    const { module, category = 'core' } = args;

    if (!module) {
      throw new McpError(
        ErrorCode.InvalidParams,
        'Module parameter is required'
      );
    }

    const docsPath = this.getModuleDocsPath(module, category);

    if (!fs.existsSync(docsPath)) {
      return {
        content: [
          {
            type: 'text',
            text: `–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –¥–ª—è –º–æ–¥—É–ª—è '${module}' –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ '${category}'`
          }
        ]
      };
    }

    const content = fs.readFileSync(docsPath, 'utf8');

    return {
      content: [
        {
          type: 'text',
          text: `# –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –º–æ–¥—É–ª—è: ${module}\n\n${content}`
        }
      ]
    };
  }

  async listModules(args) {
    const { category = 'all' } = args;
    const modules = [];

    const searchPaths = this.getSearchPaths(category);

    for (const searchPath of searchPaths) {
      if (fs.existsSync(searchPath)) {
        const files = this.findMarkdownFiles(searchPath);

        for (const file of files) {
          const moduleName = this.extractModuleName(file);
          if (moduleName && !modules.includes(moduleName)) {
            modules.push(moduleName);
          }
        }
      }
    }

    return {
      content: [
        {
          type: 'text',
          text: `–î–æ—Å—Ç—É–ø–Ω—ã–µ –º–æ–¥—É–ª–∏ –≤ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ '${category}':\n\n` +
                modules.map(m => `‚Ä¢ ${m}`).join('\n')
        }
      ]
    };
  }

  async getArchitectureInfo(args) {
    const { component = 'overview' } = args;

    let archPath;
    switch (component) {
      case 'dap-sdk':
        archPath = path.join(this.docsPath, 'dap-sdk/docs/architecture.md');
        break;
      case 'cellframe-sdk':
        archPath = path.join(this.docsPath, 'cellframe-sdk/docs/architecture.md');
        break;
      default:
        // Overview - –º–æ–∂–Ω–æ —Å–æ–∑–¥–∞—Ç—å –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
        return {
          content: [
            {
              type: 'text',
              text: `# –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ DAP SDK\n\n` +
                    `## –ö–æ–º–ø–æ–Ω–µ–Ω—Ç—ã —Å–∏—Å—Ç–µ–º—ã:\n\n` +
                    `### DAP SDK Core\n` +
                    `- **Crypto –º–æ–¥—É–ª—å**: –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ, –ø–æ–¥–ø–∏—Å–∏, —Ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ\n` +
                    `- **Net –º–æ–¥—É–ª—å**: –°–µ—Ç–µ–≤–∞—è –∫–æ–º–º—É–Ω–∏–∫–∞—Ü–∏—è, HTTP/JSON-RPC\n` +
                    `- **Core –º–æ–¥—É–ª—å**: –ë–∞–∑–æ–≤—ã–µ —É—Ç–∏–ª–∏—Ç—ã, –º–∞—Ç–µ–º–∞—Ç–∏–∫–∞, —Å—Ç—Ä–æ–∫–∏\n\n` +
                    `### CellFrame SDK\n` +
                    `- **Chain –º–æ–¥—É–ª—å**: –ë–ª–æ–∫—á–µ–π–Ω –ª–æ–≥–∏–∫–∞\n` +
                    `- **Wallet –º–æ–¥—É–ª—å**: –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–æ—à–µ–ª—å–∫–∞–º–∏\n` +
                    `- **Consensus –º–æ–¥—É–ª—å**: –ê–ª–≥–æ—Ä–∏—Ç–º—ã –∫–æ–Ω—Å–µ–Ω—Å—É—Å–∞\n` +
                    `- **Mining –º–æ–¥—É–ª—å**: –î–æ–±—ã—á–∞ –∏ –≤–∞–ª–∏–¥–∞—Ü–∏—è\n\n` +
                    `### –ú–æ–¥—É–ª–∏ DAP SDK Core:\n` +
                    `- dap_cbuf: –ö–æ–ª—å—Ü–µ–≤—ã–µ –±—É—Ñ–µ—Ä—ã\n` +
                    `- dap_math_ops: –ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏\n` +
                    `- dap_math_convert: –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è —á–∏—Å–µ–ª\n` +
                    `- portable_endian: –ö—Ä–æ—Å—Å–ø–ª–∞—Ç—Ñ–æ—Ä–º–µ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏\n` +
                    `- dap_strfuncs: –†–∞–±–æ—Ç–∞ —Å–æ —Å—Ç—Ä–æ–∫–∞–º–∏\n` +
                    `- dap_tsd: –¢–∏–ø–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è\n` +
                    `- dap_json_rpc_errors: –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ JSON-RPC\n` +
                    `- dap_fnmatch: –°–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ —à–∞–±–ª–æ–Ω–æ–≤\n`
            }
          ]
        };
    }

    if (!fs.existsSync(archPath)) {
      throw new McpError(
        ErrorCode.InternalError,
        `Architecture file not found: ${archPath}`
      );
    }

    const content = fs.readFileSync(archPath, 'utf8');

    return {
      content: [
        {
          type: 'text',
          text: `# –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ ${component}\n\n${content}`
        }
      ]
    };
  }

  getSearchPaths(category) {
    const basePaths = {
      core: ['dap-sdk/docs/modules/core'],
      crypto: ['dap-sdk/docs/modules/crypto'],
      net: ['dap-sdk/docs/modules/net'],
      cellframe: ['cellframe-sdk/docs/modules'],
      all: [
        'dap-sdk/docs/modules/core',
        'dap-sdk/docs/modules/crypto',
        'dap-sdk/docs/modules/net',
        'cellframe-sdk/docs/modules'
      ]
    };

    return (basePaths[category] || basePaths.all).map(p =>
      path.join(this.docsPath, p)
    );
  }

  findMarkdownFiles(dirPath) {
    const files = [];

    function scanDir(currentPath) {
      if (!fs.existsSync(currentPath)) return;

      const items = fs.readdirSync(currentPath);

      for (const item of items) {
        const itemPath = path.join(currentPath, item);
        const stat = fs.statSync(itemPath);

        if (stat.isDirectory()) {
          scanDir(itemPath);
        } else if (item.endsWith('.md')) {
          files.push(itemPath);
        }
      }
    }

    scanDir(dirPath);
    return files;
  }

  searchInContent(content, query) {
    const lines = content.split('\n');
    const matches = [];
    const queryLower = query.toLowerCase();

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (line.toLowerCase().includes(queryLower)) {
        // –î–æ–±–∞–≤–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç –≤–æ–∫—Ä—É–≥ –Ω–∞–π–¥–µ–Ω–Ω–æ–π —Å—Ç—Ä–æ–∫–∏
        const start = Math.max(0, i - 1);
        const end = Math.min(lines.length, i + 2);
        const context = lines.slice(start, end).join('\n');
        matches.push(context);
      }
    }

    return matches;
  }

  extractModuleName(filePath) {
    const filename = path.basename(filePath, '.md');

    // –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–ª—É—á–∞–∏
    if (filename.startsWith('dap_')) {
      return filename;
    }

    // –ü–æ–ø—ã—Ç–∫–∞ –∏–∑–≤–ª–µ—á—å –∏–º—è –º–æ–¥—É–ª—è –∏–∑ –ø—É—Ç–∏
    const relativePath = path.relative(this.docsPath, filePath);
    const parts = relativePath.split(path.sep);

    if (parts.includes('modules') && parts.includes('core')) {
      return filename;
    }

    return filename;
  }

  getModuleDocsPath(module, category) {
    const categoryPaths = {
      core: 'dap-sdk/docs/modules/core',
      crypto: 'dap-sdk/docs/modules/crypto',
      net: 'dap-sdk/docs/modules/net'
    };

    const basePath = categoryPaths[category] || categoryPaths.core;
    return path.join(this.docsPath, basePath, `${module}.md`);
  }

  async run() {
    console.error('Starting DAP SDK Documentation MCP Server...');

    const transport = new StdioServerTransport();
    await this.server.connect(transport);

    console.error('DAP SDK Documentation MCP Server started successfully');
  }
}

// –ò–º–ø–æ—Ä—Ç —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞ (–ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ—Ç—Å—è –Ω–∞–ª–∏—á–∏–µ MCP SDK)
const { StdioServerTransport } = require('@modelcontextprotocol/sdk/server/stdio.js');

// –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞
const server = new DapSdkDocsServer();
server.run().catch(error => {
  console.error('Server error:', error);
  process.exit(1);
});


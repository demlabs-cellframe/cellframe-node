{
  "project_constraints": {
    "threading_model": {
      "type": "worker_pool",
      "critical_rules": [
        "Never access objects after passing to worker thread",
        "Set all callbacks before thread handoff",
        "Cleanup resources in same thread where created"
      ],
      "unsafe_patterns": [
        "Accessing client object after dap_worker_add_work_unsafe",
        "Shared state without synchronization",
        "Cross-thread memory management"
      ]
    },
    "memory_management": {
      "allocation_macros": ["DAP_NEW", "DAP_DELETE", "DAP_FREE", "DAP_DEL_Z"],
      "rules": [
        "Always check allocation results",
        "Use DAP_DEL_Z to null pointers after free",
        "Match every allocation with deallocation",
        "Handle cleanup in error paths"
      ],
      "realloc_safety": {
        "rule": "ALWAYS use temporary variable with realloc to prevent memory leaks",
        "wrong": "ptr = DAP_REALLOC(ptr, new_size); // LEAK if realloc fails!",
        "correct": "byte_t *l_new = DAP_REALLOC(ptr, new_size); if(!l_new) return error; ptr = l_new;",
        "rationale": "If realloc fails and returns NULL, original pointer is lost but memory remains allocated"
      },
      "realloc_macros": {
        "critical_rule": "Use correct realloc macro based on function return type",
        "for_value_returning_functions": {
          "macro": "DAP_REALLOC_RET_VAL_IF_FAIL(ptr, size, return_value, cleanup_args...)",
          "examples": [
            "DAP_REALLOC_RET_VAL_IF_FAIL(l_buf, new_size, false, l_buf) // returns false on failure",
            "DAP_REALLOC_RET_VAL_IF_FAIL(l_buf, new_size, NULL, l_buf)  // returns NULL on failure"
          ]
        },
        "for_void_functions": {
          "macro": "DAP_REALLOC_RET_IF_FAIL(ptr, size, cleanup_args...)",
          "note": "Only for functions that return void"
        },
        "common_mistake": {
          "wrong": "DAP_REALLOC_RET_IF_FAIL(ptr, size, ptr) in non-void function",
          "consequence": "Will generate 'return;' instead of 'return value;'",
          "correct": "DAP_REALLOC_RET_VAL_IF_FAIL(ptr, size, false, ptr)"
        }
      }
    },
    "efficient_c_programming": {
      "parameter_handling": {
        "input_parameter_modification": {
          "when_acceptable": [
            "Parameter passed by value (not affecting caller)",
            "Parameter not used for further calculations",
            "Saves memory allocation on stack",
            "Standard pattern in system programming (like read/write syscalls)"
          ],
          "example": "Modify a_data_size to return actual processed count",
          "rationale": "Efficiency over academic purity in system code"
        }
      },
      "defensive_programming": {
        "targeted_validation": {
          "principle": "Check only where problems can actually occur",
          "rules": [
            "Validate in functions that INCREASE buffer sizes",
            "Skip redundant checks in functions that only DECREASE sizes",
            "Avoid performance penalty of excessive validation",
            "Focus checks on mutation points, not read-only operations"
          ],
          "anti_pattern": "Buffer corruption checks in pop/consume functions"
        }
      },
      "memory_optimization": {
        "variable_reuse": [
          "Reuse input parameters as return values when semantically clear",
          "Minimize local variables in hot paths",
          "Prefer stack allocation over heap when possible"
        ],
        "stack_efficiency": [
          "Use existing variables instead of creating new ones",
          "Consider memory layout and alignment",
          "Minimize function call overhead"
        ]
      },
      "context_awareness": {
        "system_vs_application": {
          "system_code": [
            "Performance and memory efficiency are primary",
            "Input parameter modification is acceptable pattern",
            "Minimal defensive programming overhead",
            "Follow kernel/embedded conventions"
          ],
          "application_code": [
            "Readability and maintainability prioritized", 
            "More defensive programming acceptable",
            "Clearer separation of concerns"
          ]
        }
      }
    },
    "error_handling": {
      "return_codes": {
        "success": 0,
        "error": -1,
        "null_pointer": "NULL",
        "boolean_false": "false"
      },
      "logging": "log_it(L_ERROR, ...)",
      "validation": "Check all input parameters for NULL at function start",
      "efficiency_first": "In system code, validate only where corruption can occur"
    },
    "platform_support": {
      "targets": ["linux", "windows", "macos", "android"],
      "conditional_compilation": "#ifdef DAP_OS_WINDOWS",
      "platform_dirs": ["win32/", "unix/", "darwin/"]
    },
    "module_structure": {
      "naming_convention": "dap_module_function",
      "log_tag_required": true,
      "public_api": "in .h files only",
      "internal_implementation": "static functions in .c files"
    }
  },
  "common_mistakes": [
    "Using objects after thread handoff",
    "Missing NULL checks",
    "Incorrect cleanup order",
    "Memory leaks in error paths",
    "Platform-specific code in common files",
    "Missing doxygen documentation",
    "Over-defensive programming in performance-critical paths",
    "Creating unnecessary variables when parameter reuse is cleaner",
    "Buffer validation in wrong places (read-only vs write operations)",
    "Direct assignment to pointer during realloc (causes memory leaks on failure)",
    "Using DAP_REALLOC_RET_IF_FAIL in non-void functions (wrong return type)"
  ],
  "performance_considerations": [
    "Minimize memory allocations in hot paths",
    "Pass large structs by pointer",
    "Use const qualifiers appropriately",
    "Avoid redundant operations",
    "Consider cache locality",
    "Reuse input parameters as return values when appropriate",
    "Target defensive programming to mutation points only",
    "Prefer stack efficiency over academic code purity in system programming"
  ],
  "design_principles": {
    "efficiency_over_purity": {
      "context": "System programming (kernel, embedded, network stack)",
      "examples": [
        "Input parameter modification for return values",
        "Minimal defensive checks in non-mutating functions",
        "Stack memory optimization over readability",
        "Performance-first approach to validation"
      ]
    },
    "contextual_best_practices": {
      "rule": "Best practices depend on code context and constraints",
      "system_code_priorities": ["Performance", "Memory efficiency", "Minimal overhead"],
      "application_code_priorities": ["Readability", "Maintainability", "Safety"]
    }
  }
} 
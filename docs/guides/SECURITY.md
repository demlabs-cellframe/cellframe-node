# üîê –†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ CellFrame DAP SDK

–≠—Ç–æ –≤—Å–µ–æ–±—ä–µ–º–ª—é—â–µ–µ —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ –æ–±–µ—Å–ø–µ—á–µ–Ω–∏—é –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π, —Ä–∞–∑—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã—Ö —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º CellFrame DAP SDK. –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å —è–≤–ª—è–µ—Ç—Å—è —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—ã–º –∞—Å–ø–µ–∫—Ç–æ–º –±–ª–æ–∫—á–µ–π–Ω —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–π –∏ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–Ω—ã—Ö —Å–∏—Å—Ç–µ–º.

## üìã –°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ

- [–í–≤–µ–¥–µ–Ω–∏–µ –≤ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å](#–≤–≤–µ–¥–µ–Ω–∏–µ-–≤-–±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å)
- [–ö—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∞—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å](#–∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∞—è-–±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å)
- [–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π](#–±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π)
- [–°–µ—Ç–µ–≤–∞—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å](#—Å–µ—Ç–µ–≤–∞—è-–±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å)
- [–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å —Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö](#–±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å-—Ö—Ä–∞–Ω–µ–Ω–∏—è-–¥–∞–Ω–Ω—ã—Ö)
- [–ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è](#–∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è-–∏-–∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è)
- [–ó–∞—â–∏—Ç–∞ –æ—Ç —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–Ω—ã—Ö –∞—Ç–∞–∫](#–∑–∞—â–∏—Ç–∞-–æ—Ç-—Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–Ω—ã—Ö-–∞—Ç–∞–∫)
- [–ê—É–¥–∏—Ç –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏](#–∞—É–¥–∏—Ç-–±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏)
- [–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏ —Ä–µ–∞–≥–∏—Ä–æ–≤–∞–Ω–∏–µ](#–º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥-–∏-—Ä–µ–∞–≥–∏—Ä–æ–≤–∞–Ω–∏–µ)
- [–õ—É—á—à–∏–µ –ø—Ä–∞–∫—Ç–∏–∫–∏](#–ª—É—á—à–∏–µ-–ø—Ä–∞–∫—Ç–∏–∫–∏)

## üîê –í–≤–µ–¥–µ–Ω–∏–µ –≤ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å

### –û—Å–Ω–æ–≤–Ω—ã–µ –ø—Ä–∏–Ω—Ü–∏–ø—ã –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏

**CIA Triad** - —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω–∞—è –º–æ–¥–µ–ª—å –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏:
- **Confidentiality (–ö–æ–Ω—Ñ–∏–¥–µ–Ω—Ü–∏–∞–ª—å–Ω–æ—Å—Ç—å)** - –∑–∞—â–∏—Ç–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ—Ç –Ω–µ—Å–∞–Ω–∫—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞
- **Integrity (–¶–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç—å)** - –æ–±–µ—Å–ø–µ—á–µ–Ω–∏–µ –Ω–µ–∏–∑–º–µ–Ω–Ω–æ—Å—Ç–∏ –¥–∞–Ω–Ω—ã—Ö
- **Availability (–î–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å)** - –æ–±–µ—Å–ø–µ—á–µ–Ω–∏–µ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ —Å–∏—Å—Ç–µ–º—ã

### –°–ø–µ—Ü–∏—Ñ–∏–∫–∞ –±–ª–æ–∫—á–µ–π–Ω –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏

```c
// –ë–ª–æ–∫—á–µ–π–Ω-—Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ —É–≥—Ä–æ–∑—ã
typedef enum blockchain_threats {
    THREAT_DOUBLE_SPENDING,      // –î–≤–æ–π–Ω–∞—è —Ç—Ä–∞—Ç–∞
    THREAT_51_PERCENT_ATTACK,    // –ê—Ç–∞–∫–∞ 51%
    THREAT_SYBIL_ATTACK,         // Sybil –∞—Ç–∞–∫–∞
    THREAT_ECLIPSE_ATTACK,       // Eclipse –∞—Ç–∞–∫–∞
    THREAT_REPLAY_ATTACK,        // Replay –∞—Ç–∞–∫–∞
    THREAT_FRONT_RUNNING,        // Front-running
    THREAT_SANDBOX_ESCAPE,       // Escape –∏–∑ sandbox
    THREAT_SUPPLY_CHAIN_ATTACK,  // –ê—Ç–∞–∫–∞ —Ü–µ–ø–æ—á–∫–∏ –ø–æ—Å—Ç–∞–≤–æ–∫
} blockchain_threats_t;
```

### Zero Trust –º–æ–¥–µ–ª—å

```c
// –ü—Ä–∏–Ω—Ü–∏–ø—ã Zero Trust
#define ZERO_TRUST_PRINCIPLES \
    "Never trust, always verify", \
    "Assume breach", \
    "Verify explicitly", \
    "Use least privilege", \
    "Log everything"

// –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –≤ –∫–æ–¥–µ
bool zero_trust_verify(dap_stream_node_addr_t *node_addr,
                      dap_sign_t *signature,
                      const void *data, size_t data_size) {
    // –í—Å–µ–≥–¥–∞ –ø—Ä–æ–≤–µ—Ä—è—Ç—å, –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –¥–æ–≤–µ—Ä—è—Ç—å
    if (!node_addr || !signature || !data) {
        return false;
    }

    // –Ø–≤–Ω–∞—è –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è
    return dap_sign_verify(signature, data, data_size);
}
```

## üîë –ö—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∞—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å

### –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–ª—é—á–∞–º–∏

#### –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–ª—é—á–µ–π

```c
// –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–ª—é—á–µ–π
dap_enc_key_t *generate_secure_key(dap_enc_key_type_t key_type,
                                  size_t key_size) {
    // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ RNG
    dap_enc_key_t *key = dap_enc_key_new_generate(key_type, key_size, NULL);

    // –í–∞–ª–∏–¥–∞—Ü–∏—è –∫–ª—é—á–∞
    if (!dap_enc_key_is_valid(key)) {
        dap_enc_key_delete(key);
        return NULL;
    }

    return key;
}
```

#### –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Ö—Ä–∞–Ω–µ–Ω–∏–µ –∫–ª—é—á–µ–π

```c
// –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∫–ª—é—á–µ–π —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –º–∞—Å—Ç–µ—Ä-–ø–∞—Ä–æ–ª—è
typedef struct secure_key_storage {
    uint8_t salt[32];           // Salt –¥–ª—è PBKDF2
    uint8_t iv[16];             // IV –¥–ª—è AES
    uint8_t encrypted_key[64];  // –ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–ª—é—á
    uint32_t iterations;        // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏—Ç–µ—Ä–∞—Ü–∏–π PBKDF2
} secure_key_storage_t;

bool store_key_securely(dap_enc_key_t *key, const char *password,
                       secure_key_storage_t *storage) {

    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è salt
    if (RAND_bytes(storage->salt, sizeof(storage->salt)) != 1) {
        return false;
    }

    // PBKDF2 –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–ª—é—á–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
    uint8_t derived_key[32];
    if (!PKCS5_PBKDF2_HMAC(password, strlen(password),
                          storage->salt, sizeof(storage->salt),
                          storage->iterations, EVP_sha256(),
                          sizeof(derived_key), derived_key)) {
        return false;
    }

    // –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞
    // ...

    return true;
}
```

#### –†–æ—Ç–∞—Ü–∏—è –∫–ª—é—á–µ–π

```c
// –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Ä–æ—Ç–∞—Ü–∏—è –∫–ª—é—á–µ–π
typedef struct key_rotation_policy {
    time_t rotation_interval;   // –ò–Ω—Ç–µ—Ä–≤–∞–ª —Ä–æ—Ç–∞—Ü–∏–∏
    time_t last_rotation;       // –ü–æ—Å–ª–µ–¥–Ω—è—è —Ä–æ—Ç–∞—Ü–∏—è
    size_t max_keys;           // –ú–∞–∫—Å–∏–º—É–º –∞–∫—Ç–∏–≤–Ω—ã—Ö –∫–ª—é—á–µ–π
    bool emergency_rotation;   // –≠–∫—Å—Ç—Ä–µ–Ω–Ω–∞—è —Ä–æ—Ç–∞—Ü–∏—è
} key_rotation_policy_t;

bool should_rotate_keys(key_rotation_policy_t *policy) {
    time_t now = time(NULL);
    return (now - policy->last_rotation) > policy->rotation_interval ||
           policy->emergency_rotation;
}

int rotate_keys(dap_enc_key_t **old_key, dap_enc_key_t **new_key) {
    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–æ–≤–æ–≥–æ –∫–ª—é—á–∞
    *new_key = generate_secure_key(DAP_ENC_KEY_TYPE_SIG_ECDSA, 256);
    if (!*new_key) return -1;

    // –ü–µ—Ä–µ—Ö–æ–¥–Ω—ã–π –ø–µ—Ä–∏–æ–¥ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –æ–±–æ–∏—Ö –∫–ª—é—á–µ–π
    // ...

    // –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ —Å—Ç–∞—Ä–æ–≥–æ –∫–ª—é—á–∞
    dap_enc_key_delete(*old_key);
    *old_key = *new_key;

    return 0;
}
```

### –¶–∏—Ñ—Ä–æ–≤—ã–µ –ø–æ–¥–ø–∏—Å–∏

#### –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–¥–ø–∏—Å–µ–π

```c
// –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Å–æ–∑–¥–∞–Ω–∏–µ –ø–æ–¥–ø–∏—Å–∏
dap_sign_t *create_secure_signature(dap_enc_key_t *private_key,
                                  const void *data, size_t data_size) {

    if (!private_key || !data || data_size == 0) {
        return NULL;
    }

    // –í—ã—á–∏—Å–ª–µ–Ω–∏–µ —Ö—ç—à–∞ –¥–∞–Ω–Ω—ã—Ö
    uint8_t hash[32];
    if (dap_hash_fast(data, data_size, hash) != 0) {
        return NULL;
    }

    // –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–¥–ø–∏—Å–∏
    return dap_sign_create(private_key, hash, sizeof(hash));
}
```

#### –í–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è –ø–æ–¥–ø–∏—Å–µ–π

```c
// –ö–æ–º–ø–ª–µ–∫—Å–Ω–∞—è –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è –ø–æ–¥–ø–∏—Å–∏
typedef struct signature_verification_result {
    bool is_valid;
    const char *error_message;
    time_t verification_time;
    const char *algorithm_used;
} signature_verification_result_t;

signature_verification_result_t verify_signature_comprehensive(
    dap_sign_t *signature, const void *data, size_t data_size,
    dap_pkey_t *public_key) {

    signature_verification_result_t result = {0};

    result.verification_time = time(NULL);

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Ö–æ–¥–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
    if (!signature || !data || !public_key) {
        result.error_message = "Invalid parameters";
        return result;
    }

    // –í–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è –ø–æ–¥–ø–∏—Å–∏
    result.is_valid = dap_sign_verify(signature, data, data_size);

    // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∞–ª–≥–æ—Ä–∏—Ç–º–∞
    result.algorithm_used = dap_sign_get_algorithm_name(signature);

    if (!result.is_valid) {
        result.error_message = "Signature verification failed";
    }

    return result;
}
```

## üõ°Ô∏è –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π

### Input Validation

#### –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö

```c
// –ö–æ–º–ø–ª–µ–∫—Å–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
typedef struct input_validation_rules {
    size_t min_length;
    size_t max_length;
    const char *allowed_chars;
    bool allow_null;
    bool trim_whitespace;
} input_validation_rules_t;

bool validate_input_string(const char *input,
                          input_validation_rules_t *rules) {

    if (!input && !rules->allow_null) {
        return false;
    }

    if (!input) return true;

    size_t length = strlen(input);

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª–∏–Ω—ã
    if (length < rules->min_length || length > rules->max_length) {
        return false;
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–∏–º–≤–æ–ª–æ–≤
    if (rules->allowed_chars) {
        for (size_t i = 0; i < length; i++) {
            if (!strchr(rules->allowed_chars, input[i])) {
                return false;
            }
        }
    }

    return true;
}

// –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –≤–∞–ª–∏–¥–∞—Ü–∏–∏
bool process_user_input(const char *user_input) {
    input_validation_rules_t rules = {
        .min_length = 1,
        .max_length = 256,
        .allowed_chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-.",
        .allow_null = false,
        .trim_whitespace = true
    };

    if (!validate_input_string(user_input, &rules)) {
        log_security_event("Invalid user input detected", user_input);
        return false;
    }

    return true;
}
```

#### –ó–∞—â–∏—Ç–∞ –æ—Ç SQL Injection

```c
// –ë–µ–∑–æ–ø–∞—Å–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
typedef struct safe_query_builder {
    GString *query;
    GPtrArray *parameters;
} safe_query_builder_t;

safe_query_builder_t *query_builder_new(const char *base_query) {
    safe_query_builder_t *builder = g_new(safe_query_builder_t, 1);
    builder->query = g_string_new(base_query);
    builder->parameters = g_ptr_array_new_with_free_func(g_free);
    return builder;
}

void query_builder_add_param(safe_query_builder_t *builder,
                           const char *param_name, const char *param_value) {

    // –≠–∫—Ä–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤
    char *escaped_value = g_strescape(param_value, NULL);

    // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞
    g_string_append_printf(builder->query, " %s = '%s'",
                          param_name, escaped_value);

    g_free(escaped_value);
}

char *query_builder_get_query(safe_query_builder_t *builder) {
    return g_string_free(builder->query, FALSE);
}
```

### Memory Safety

#### –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–∞–º—è—Ç—å—é

```c
// RAII –ø–∞—Ç—Ç–µ—Ä–Ω –¥–ª—è C
typedef struct safe_buffer {
    uint8_t *data;
    size_t size;
    size_t capacity;
    bool owns_memory;
} safe_buffer_t;

safe_buffer_t *safe_buffer_new(size_t initial_capacity) {
    safe_buffer_t *buffer = calloc(1, sizeof(safe_buffer_t));
    if (!buffer) return NULL;

    buffer->data = calloc(1, initial_capacity);
    if (!buffer->data) {
        free(buffer);
        return NULL;
    }

    buffer->size = 0;
    buffer->capacity = initial_capacity;
    buffer->owns_memory = true;

    return buffer;
}

void safe_buffer_free(safe_buffer_t *buffer) {
    if (!buffer) return;

    if (buffer->owns_memory && buffer->data) {
        // –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
        memset(buffer->data, 0, buffer->capacity);
        free(buffer->data);
    }

    free(buffer);
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
void process_sensitive_data() {
    safe_buffer_t *buffer = safe_buffer_new(1024);
    if (!buffer) return;

    // –†–∞–±–æ—Ç–∞ —Å –¥–∞–Ω–Ω—ã–º–∏
    // ...

    // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –±–µ–∑–æ–ø–∞—Å–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞
    safe_buffer_free(buffer);
}
```

#### –ó–∞—â–∏—Ç–∞ –æ—Ç buffer overflow

```c
// –ë–µ–∑–æ–ø–∞—Å–Ω—ã–µ —Å—Ç—Ä–æ–∫–æ–≤—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
bool safe_strncpy(char *dest, size_t dest_size,
                 const char *src, size_t src_size) {

    if (!dest || !src || dest_size == 0) {
        return false;
    }

    size_t copy_size = (src_size < dest_size) ? src_size : dest_size - 1;
    memcpy(dest, src, copy_size);
    dest[copy_size] = '\0';

    return true;
}

// –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –∫–æ–Ω–∫–∞—Ç–µ–Ω–∞—Ü–∏—è —Å—Ç—Ä–æ–∫
bool safe_strncat(char *dest, size_t dest_size,
                 const char *src, size_t src_size) {

    size_t dest_len = strnlen(dest, dest_size);
    if (dest_len >= dest_size) {
        return false; // dest —É–∂–µ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω
    }

    size_t remaining = dest_size - dest_len;
    size_t copy_size = (src_size < remaining) ? src_size : remaining - 1;

    memcpy(dest + dest_len, src, copy_size);
    dest[dest_len + copy_size] = '\0';

    return true;
}
```

## üåê –°–µ—Ç–µ–≤–∞—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å

### TLS/SSL —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ

#### –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∑–∞—â–∏—â–µ–Ω–Ω–æ–≥–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è

```c
// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è TLS
typedef struct tls_config {
    const char *certificate_file;
    const char *private_key_file;
    const char *ca_certificate_file;
    const char *cipher_list;
    bool require_client_cert;
    int min_tls_version;
    bool enable_hsts;
} tls_config_t;

dap_ssl_context_t *create_secure_ssl_context(tls_config_t *config) {

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è OpenSSL
    SSL_library_init();
    OpenSSL_add_all_algorithms();
    SSL_load_error_strings();

    // –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
    const SSL_METHOD *method = TLS_server_method();
    SSL_CTX *ctx = SSL_CTX_new(method);

    if (!ctx) {
        log_ssl_error("Failed to create SSL context");
        return NULL;
    }

    // –ó–∞–≥—Ä—É–∑–∫–∞ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–∞
    if (SSL_CTX_use_certificate_file(ctx, config->certificate_file,
                                   SSL_FILETYPE_PEM) <= 0) {
        log_ssl_error("Failed to load certificate");
        SSL_CTX_free(ctx);
        return NULL;
    }

    // –ó–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞
    if (SSL_CTX_use_PrivateKey_file(ctx, config->private_key_file,
                                  SSL_FILETYPE_PEM) <= 0) {
        log_ssl_error("Failed to load private key");
        SSL_CTX_free(ctx);
        return NULL;
    }

    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —à–∏—Ñ—Ä–æ–≤
    if (!SSL_CTX_set_cipher_list(ctx, config->cipher_list)) {
        log_ssl_error("Failed to set cipher list");
        SSL_CTX_free(ctx);
        return NULL;
    }

    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π –≤–µ—Ä—Å–∏–∏ TLS
    SSL_CTX_set_min_proto_version(ctx, config->min_tls_version);

    return ctx;
}
```

#### –ó–∞—â–∏—Ç–∞ –æ—Ç —Å–µ—Ç–µ–≤—ã—Ö –∞—Ç–∞–∫

```c
// Rate limiting
typedef struct rate_limiter {
    uint32_t max_requests_per_minute;
    uint32_t current_requests;
    time_t window_start;
    GHashTable *client_requests; // IP -> request_count
} rate_limiter_t;

bool check_rate_limit(rate_limiter_t *limiter,
                     const char *client_ip,
                     time_t current_time) {

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–∫–Ω–∞ –≤—Ä–µ–º–µ–Ω–∏
    if (current_time - limiter->window_start >= 60) {
        // –°–±—Ä–æ—Å —Å—á–µ—Ç—á–∏–∫–æ–≤
        limiter->current_requests = 0;
        limiter->window_start = current_time;
        g_hash_table_remove_all(limiter->client_requests);
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω–æ–≥–æ –ª–∏–º–∏—Ç–∞ –∫–ª–∏–µ–Ω—Ç–∞
    uint32_t *client_count = g_hash_table_lookup(limiter->client_requests,
                                                client_ip);
    if (!client_count) {
        client_count = g_new(uint32_t, 1);
        *client_count = 0;
        g_hash_table_insert(limiter->client_requests, g_strdup(client_ip),
                           client_count);
    }

    if (*client_count >= limiter->max_requests_per_minute) {
        return false; // –ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç
    }

    (*client_count)++;
    limiter->current_requests++;

    return limiter->current_requests < limiter->max_requests_per_minute;
}
```

#### –ó–∞—â–∏—Ç–∞ –æ—Ç DDoS

```c
// DDoS mitigation
typedef struct ddos_protection {
    rate_limiter_t *rate_limiter;
    GHashTable *blacklist;       // –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ IP
    GHashTable *whitelist;       // –î–æ–≤–µ—Ä–µ–Ω–Ω—ã–µ IP
    uint32_t max_connections;
    uint32_t current_connections;
    pthread_mutex_t mutex;
} ddos_protection_t;

connection_result_t check_connection_allowed(ddos_protection_t *ddos,
                                          const char *client_ip,
                                          const char *user_agent) {

    pthread_mutex_lock(&ddos->mutex);

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ blacklist
    if (g_hash_table_contains(ddos->blacklist, client_ip)) {
        pthread_mutex_unlock(&ddos->mutex);
        return CONNECTION_BLOCKED;
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ whitelist
    if (g_hash_table_contains(ddos->whitelist, client_ip)) {
        pthread_mutex_unlock(&ddos->mutex);
        return CONNECTION_ALLOWED;
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ rate limit
    if (!check_rate_limit(ddos->rate_limiter, client_ip, time(NULL))) {
        // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ blacklist
        g_hash_table_add(ddos->blacklist, g_strdup(client_ip));
        pthread_mutex_unlock(&ddos->mutex);
        return CONNECTION_BLOCKED;
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
    if (ddos->current_connections >= ddos->max_connections) {
        pthread_mutex_unlock(&ddos->mutex);
        return CONNECTION_REJECTED;
    }

    ddos->current_connections++;
    pthread_mutex_unlock(&ddos->mutex);

    return CONNECTION_ALLOWED;
}
```

## üíæ –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å —Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö

### –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö

```c
// –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
typedef struct encrypted_database {
    const char *db_path;
    uint8_t master_key[32];
    uint8_t salt[16];
    bool use_hardware_encryption;
} encrypted_database_t;

int encrypt_database_record(const void *plaintext, size_t plaintext_size,
                           void **ciphertext, size_t *ciphertext_size,
                           encrypted_database_t *db) {

    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è IV
    uint8_t iv[16];
    if (RAND_bytes(iv, sizeof(iv)) != 1) {
        return -1;
    }

    // –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ AES-256-GCM
    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
    if (!ctx) return -1;

    if (EVP_EncryptInit_ex(ctx, EVP_aes_256_gcm(),
                          NULL, db->master_key, iv) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        return -1;
    }

    *ciphertext_size = plaintext_size + 16 + 12; // data + tag + iv
    *ciphertext = malloc(*ciphertext_size);
    if (!*ciphertext) {
        EVP_CIPHER_CTX_free(ctx);
        return -1;
    }

    int len;
    if (EVP_EncryptUpdate(ctx, *ciphertext, &len,
                         plaintext, plaintext_size) != 1) {
        free(*ciphertext);
        EVP_CIPHER_CTX_free(ctx);
        return -1;
    }

    if (EVP_EncryptFinal_ex(ctx, *ciphertext + len, &len) != 1) {
        free(*ciphertext);
        EVP_CIPHER_CTX_free(ctx);
        return -1;
    }

    EVP_CIPHER_CTX_free(ctx);
    return 0;
}
```

### Secure Delete

```c
// –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ —Ñ–∞–π–ª–æ–≤
int secure_delete_file(const char *filepath, int passes) {
    struct stat st;

    if (stat(filepath, &st) != 0) {
        return -1; // –§–∞–π–ª –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    }

    int fd = open(filepath, O_WRONLY);
    if (fd == -1) {
        return -1;
    }

    // –ù–µ—Å–∫–æ–ª—å–∫–æ –ø—Ä–æ—Ö–æ–¥–æ–≤ –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∏
    for (int pass = 0; pass < passes; pass++) {
        uint8_t pattern;

        switch (pass) {
            case 0: pattern = 0x00; break; // –í—Å–µ –Ω—É–ª–∏
            case 1: pattern = 0xFF; break; // –í—Å–µ –µ–¥–∏–Ω–∏—Ü—ã
            default: pattern = rand() % 256; break; // –°–ª—É—á–∞–π–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
        }

        if (lseek(fd, 0, SEEK_SET) == -1) {
            close(fd);
            return -1;
        }

        // –ü–µ—Ä–µ–∑–∞–ø–∏—Å—å —Ñ–∞–π–ª–∞
        for (off_t offset = 0; offset < st.st_size; ) {
            size_t chunk_size = (st.st_size - offset > 4096) ?
                               4096 : st.st_size - offset;

            uint8_t buffer[4096];
            memset(buffer, pattern, chunk_size);

            if (write(fd, buffer, chunk_size) != chunk_size) {
                close(fd);
                return -1;
            }

            offset += chunk_size;
        }

        // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è
        if (fsync(fd) != 0) {
            close(fd);
            return -1;
        }
    }

    close(fd);

    // –§–∏–∑–∏—á–µ—Å–∫–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ
    if (unlink(filepath) != 0) {
        return -1;
    }

    return 0;
}
```

## üîí –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è

### Multi-factor Authentication

```c
// MFA —Å–∏—Å—Ç–µ–º–∞
typedef struct mfa_context {
    const char *username;
    uint8_t secret[32];         // TOTP secret
    time_t last_auth_time;
    uint32_t failed_attempts;
    bool is_locked;
    time_t lock_until;
} mfa_context_t;

typedef enum mfa_result {
    MFA_SUCCESS,
    MFA_INVALID_CODE,
    MFA_EXPIRED_CODE,
    MFA_ACCOUNT_LOCKED,
    MFA_SYSTEM_ERROR
} mfa_result_t;

mfa_result_t verify_totp_code(mfa_context_t *context,
                             const char *user_code,
                             time_t current_time) {

    if (context->is_locked) {
        if (current_time < context->lock_until) {
            return MFA_ACCOUNT_LOCKED;
        } else {
            // –°–±—Ä–æ—Å –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
            context->is_locked = false;
            context->failed_attempts = 0;
        }
    }

    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ–∂–∏–¥–∞–µ–º–æ–≥–æ –∫–æ–¥–∞
    uint32_t expected_code = generate_totp_code(context->secret,
                                               current_time / 30);

    char expected_str[7];
    snprintf(expected_str, sizeof(expected_str), "%06u", expected_code);

    if (strcmp(user_code, expected_str) == 0) {
        context->last_auth_time = current_time;
        context->failed_attempts = 0;
        return MFA_SUCCESS;
    }

    // –ù–µ—É–¥–∞—á–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞
    context->failed_attempts++;

    if (context->failed_attempts >= 5) {
        context->is_locked = true;
        context->lock_until = current_time + 900; // 15 –º–∏–Ω—É—Ç
    }

    return MFA_INVALID_CODE;
}
```

### Role-Based Access Control

```c
// RBAC —Å–∏—Å—Ç–µ–º–∞
typedef enum user_role {
    ROLE_GUEST,
    ROLE_USER,
    ROLE_MODERATOR,
    ROLE_ADMIN,
    ROLE_SUPER_ADMIN
} user_role_t;

typedef struct permission {
    const char *resource;
    const char *action;
    user_role_t min_role;
} permission_t;

// –¢–∞–±–ª–∏—Ü–∞ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–π
static const permission_t permissions[] = {
    {"wallet", "read", ROLE_USER},
    {"wallet", "send", ROLE_USER},
    {"wallet", "create", ROLE_USER},
    {"network", "read", ROLE_GUEST},
    {"network", "configure", ROLE_ADMIN},
    {"system", "shutdown", ROLE_SUPER_ADMIN},
    {NULL, NULL, 0}
};

bool check_permission(user_role_t user_role,
                     const char *resource,
                     const char *action) {

    for (const permission_t *perm = permissions; perm->resource; perm++) {
        if (strcmp(perm->resource, resource) == 0 &&
            strcmp(perm->action, action) == 0) {

            return user_role >= perm->min_role;
        }
    }

    return false; // –†–∞–∑—Ä–µ—à–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
}
```

## üõ°Ô∏è –ó–∞—â–∏—Ç–∞ –æ—Ç —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–Ω—ã—Ö –∞—Ç–∞–∫

### –ó–∞—â–∏—Ç–∞ –æ—Ç SQL Injection

```c
// –ü–∞—Ä–∞–º–µ—Ç—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã
typedef struct safe_sql_query {
    GString *query_template;
    GPtrArray *parameters;
    GHashTable *param_types;
} safe_sql_query_t;

safe_sql_query_t *safe_sql_query_new(const char *template) {
    safe_sql_query_t *query = g_new(safe_sql_query_t, 1);
    query->query_template = g_string_new(template);
    query->parameters = g_ptr_array_new();
    query->param_types = g_hash_table_new(g_str_hash, g_str_equal);
    return query;
}

void safe_sql_query_add_param(safe_sql_query_t *query,
                             const char *name, const void *value,
                             const char *type) {

    g_ptr_array_add(query->parameters, g_strdup(name));
    g_hash_table_insert(query->param_types, g_strdup(name), g_strdup(type));

    // –ó–∞–º–µ–Ω–∞ –ø–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä–∞ –Ω–∞ –±–µ–∑–æ–ø–∞—Å–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä
    char *placeholder = g_strdup_printf(":%s", name);
    g_string_replace(query->query_template, placeholder, "?", 0);
    g_free(placeholder);
}

char *safe_sql_query_execute(safe_sql_query_t *query,
                           sqlite3 *db) {

    sqlite3_stmt *stmt;
    const char *sql = query->query_template->str;

    if (sqlite3_prepare_v2(db, sql, -1, &stmt, NULL) != SQLITE_OK) {
        return NULL;
    }

    // –ü—Ä–∏–≤—è–∑–∫–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
    for (guint i = 0; i < query->parameters->len; i++) {
        const char *param_name = g_ptr_array_index(query->parameters, i);
        const char *param_type = g_hash_table_lookup(query->param_types, param_name);

        // –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –ø—Ä–∏–≤—è–∑–∫–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞
        // ...
    }

    // –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–∞
    // ...

    sqlite3_finalize(stmt);
    return result;
}
```

### –ó–∞—â–∏—Ç–∞ –æ—Ç XSS

```c
// HTML escaping
char *html_escape(const char *input) {
    GString *escaped = g_string_new("");

    for (const char *p = input; *p; p++) {
        switch (*p) {
            case '<': g_string_append(escaped, "&lt;"); break;
            case '>': g_string_append(escaped, "&gt;"); break;
            case '&': g_string_append(escaped, "&amp;"); break;
            case '"': g_string_append(escaped, "&quot;"); break;
            case '\'': g_string_append(escaped, "&#x27;"); break;
            case '/': g_string_append(escaped, "&#x2F;"); break;
            default: g_string_append_c(escaped, *p); break;
        }
    }

    return g_string_free(escaped, FALSE);
}

// CSP (Content Security Policy) headers
const char *get_csp_header() {
    return "default-src 'self'; "
           "script-src 'self' 'unsafe-inline'; "
           "style-src 'self' 'unsafe-inline'; "
           "img-src 'self' data: https:; "
           "font-src 'self'; "
           "connect-src 'self'; "
           "media-src 'self'; "
           "object-src 'none'; "
           "frame-ancestors 'none';";
}

// –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è HTML
char *generate_safe_html(const char *user_input) {
    char *escaped = html_escape(user_input);

    char *html = g_markup_printf_escaped(
        "<div class=\"user-content\">%s</div>",
        escaped
    );

    g_free(escaped);
    return html;
}
```

### –ó–∞—â–∏—Ç–∞ –æ—Ç CSRF

```c
// CSRF —Ç–æ–∫–µ–Ω—ã
typedef struct csrf_protection {
    GHashTable *tokens;         // session_id -> token
    time_t token_lifetime;      // –í—Ä–µ–º—è –∂–∏–∑–Ω–∏ —Ç–æ–∫–µ–Ω–∞
    pthread_mutex_t mutex;
} csrf_protection_t;

char *generate_csrf_token(csrf_protection_t *csrf,
                         const char *session_id) {

    pthread_mutex_lock(&csrf->mutex);

    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ —Ç–æ–∫–µ–Ω–∞
    uint8_t random_bytes[32];
    if (RAND_bytes(random_bytes, sizeof(random_bytes)) != 1) {
        pthread_mutex_unlock(&csrf->mutex);
        return NULL;
    }

    char *token = g_base64_encode(random_bytes, sizeof(random_bytes));

    // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ç–æ–∫–µ–Ω–∞
    g_hash_table_insert(csrf->tokens,
                       g_strdup(session_id),
                       g_strdup(token));

    pthread_mutex_unlock(&csrf->mutex);
    return token;
}

bool validate_csrf_token(csrf_protection_t *csrf,
                        const char *session_id,
                        const char *token) {

    pthread_mutex_lock(&csrf->mutex);

    const char *stored_token = g_hash_table_lookup(csrf->tokens, session_id);

    bool is_valid = stored_token && strcmp(stored_token, token) == 0;

    if (is_valid) {
        // –û–¥–Ω–æ—Ä–∞–∑–æ–≤—ã–π —Ç–æ–∫–µ–Ω - —É–¥–∞–ª—è–µ–º –ø–æ—Å–ª–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
        g_hash_table_remove(csrf->tokens, session_id);
    }

    pthread_mutex_unlock(&csrf->mutex);
    return is_valid;
}
```

## üîç –ê—É–¥–∏—Ç –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏

### –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏–π –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏

```c
// –°—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
typedef struct security_event {
    time_t timestamp;
    const char *event_type;
    const char *severity;
    const char *source_ip;
    const char *user_id;
    const char *resource;
    const char *action;
    const char *result;
    const char *details;
} security_event_t;

void log_security_event(security_event_t *event) {
    // JSON —Ñ–æ—Ä–º–∞—Ç –¥–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
    printf("{\"timestamp\":%ld,\"event_type\":\"%s\",\"severity\":\"%s\","
           "\"source_ip\":\"%s\",\"user_id\":\"%s\",\"resource\":\"%s\","
           "\"action\":\"%s\",\"result\":\"%s\",\"details\":\"%s\"}\n",
           event->timestamp, event->event_type, event->severity,
           event->source_ip, event->user_id, event->resource,
           event->action, event->result, event->details);

    // –¢–∞–∫–∂–µ –ø–∏—à–µ–º –≤ syslog
    syslog(LOG_AUTH | LOG_INFO, "Security event: %s from %s",
           event->event_type, event->source_ip);
}

// –ú–∞–∫—Ä–æ—Å—ã –¥–ª—è —É–¥–æ–±–Ω–æ–≥–æ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
#define LOG_AUTH_SUCCESS(user, ip, action) \
    do { \
        security_event_t event = { \
            .timestamp = time(NULL), \
            .event_type = "authentication", \
            .severity = "info", \
            .source_ip = ip, \
            .user_id = user, \
            .action = action, \
            .result = "success" \
        }; \
        log_security_event(&event); \
    } while(0)

#define LOG_AUTH_FAILURE(user, ip, reason) \
    do { \
        security_event_t event = { \
            .timestamp = time(NULL), \
            .event_type = "authentication", \
            .severity = "warning", \
            .source_ip = ip, \
            .user_id = user, \
            .action = "login", \
            .result = "failure", \
            .details = reason \
        }; \
        log_security_event(&event); \
    } while(0)
```

### –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –∞—É–¥–∏—Ç

```c
// –°–∫–∞–Ω–µ—Ä —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π
typedef struct vulnerability_scan {
    const char *target;
    GPtrArray *vulnerabilities;
    time_t scan_start;
    time_t scan_end;
    bool scan_completed;
} vulnerability_scan_t;

typedef struct vulnerability {
    const char *cve_id;
    const char *severity;
    const char *description;
    const char *affected_component;
    const char *remediation;
    bool exploitable;
} vulnerability_t;

vulnerability_scan_t *run_security_audit(const char *target_system) {
    vulnerability_scan_t *scan = g_new(vulnerability_scan_t, 1);
    scan->target = g_strdup(target_system);
    scan->vulnerabilities = g_ptr_array_new();
    scan->scan_start = time(NULL);

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
    check_configuration_vulnerabilities(scan);

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
    check_dependency_vulnerabilities(scan);

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–¥–∞
    check_code_vulnerabilities(scan);

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä—ã
    check_infrastructure_vulnerabilities(scan);

    scan->scan_end = time(NULL);
    scan->scan_completed = true;

    return scan;
}

void check_configuration_vulnerabilities(vulnerability_scan_t *scan) {
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–ª–∞–±—ã—Ö –ø–∞—Ä–æ–ª–µ–π
    if (has_weak_passwords()) {
        vulnerability_t *vuln = g_new(vulnerability_t, 1);
        vuln->cve_id = "CONFIG-001";
        vuln->severity = "high";
        vuln->description = "Weak password policy detected";
        vuln->remediation = "Implement strong password requirements";
        vuln->exploitable = true;
        g_ptr_array_add(scan->vulnerabilities, vuln);
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –ø–æ—Ä—Ç–æ–≤
    // ...

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞ –∫ —Ñ–∞–π–ª–∞–º
    // ...
}
```

## üìä –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏ —Ä–µ–∞–≥–∏—Ä–æ–≤–∞–Ω–∏–µ

### Security Information and Event Management

```c
// SIEM –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è
typedef struct siem_integration {
    const char *siem_endpoint;
    const char *api_key;
    GQueue *event_queue;
    pthread_t worker_thread;
    bool running;
    pthread_mutex_t queue_mutex;
    pthread_cond_t queue_cond;
} siem_integration_t;

void siem_send_event(siem_integration_t *siem,
                    security_event_t *event) {

    pthread_mutex_lock(&siem->queue_mutex);

    // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è –≤ –æ—á–µ—Ä–µ–¥—å
    security_event_t *event_copy = g_memdup(event, sizeof(security_event_t));
    g_queue_push_tail(siem->event_queue, event_copy);

    // –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —Ä–∞–±–æ—á–µ–≥–æ –ø–æ—Ç–æ–∫–∞
    pthread_cond_signal(&siem->queue_cond);

    pthread_mutex_unlock(&siem->queue_mutex);
}

void *siem_worker_thread(void *arg) {
    siem_integration_t *siem = (siem_integration_t *)arg;

    while (siem->running) {
        pthread_mutex_lock(&siem->queue_mutex);

        // –û–∂–∏–¥–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏–π
        while (g_queue_is_empty(siem->event_queue) && siem->running) {
            pthread_cond_wait(&siem->queue_cond, &siem->queue_mutex);
        }

        if (!siem->running) {
            pthread_mutex_unlock(&siem->queue_mutex);
            break;
        }

        // –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è –∏–∑ –æ—á–µ—Ä–µ–¥–∏
        security_event_t *event = g_queue_pop_head(siem->event_queue);
        pthread_mutex_unlock(&siem->queue_mutex);

        // –û—Ç–ø—Ä–∞–≤–∫–∞ –≤ SIEM
        send_to_siem(siem, event);
        g_free(event);
    }

    return NULL;
}
```

### Incident Response

```c
// –°–∏—Å—Ç–µ–º–∞ —Ä–µ–∞–≥–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–∞ –∏–Ω—Ü–∏–¥–µ–Ω—Ç—ã
typedef struct incident_response {
    GHashTable *active_incidents;
    GPtrArray *response_playbooks;
    GHashTable *escalation_matrix;
    pthread_mutex_t mutex;
} incident_response_t;

typedef struct incident {
    const char *id;
    const char *type;
    const char *severity;
    time_t detected_time;
    const char *description;
    GPtrArray *affected_systems;
    const char *assigned_to;
    const char *status;
    GPtrArray *actions_taken;
} incident_t;

void handle_security_incident(incident_response_t *ir,
                             const char *incident_type,
                             const char *description,
                             const char *severity) {

    // –°–æ–∑–¥–∞–Ω–∏–µ –∏–Ω—Ü–∏–¥–µ–Ω—Ç–∞
    incident_t *incident = g_new(incident_t, 1);
    incident->id = generate_incident_id();
    incident->type = g_strdup(incident_type);
    incident->severity = g_strdup(severity);
    incident->detected_time = time(NULL);
    incident->description = g_strdup(description);
    incident->status = "investigating";
    incident->actions_taken = g_ptr_array_new();

    // –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∏–Ω—Ü–∏–¥–µ–Ω—Ç–∞
    pthread_mutex_lock(&ir->mutex);
    g_hash_table_insert(ir->active_incidents,
                       g_strdup(incident->id), incident);
    pthread_mutex_unlock(&ir->mutex);

    // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Ä–µ–∞–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
    execute_response_playbook(ir, incident);

    // –≠—Å–∫–∞–ª–∞—Ü–∏—è –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
    if (strcmp(severity, "critical") == 0) {
        escalate_incident(ir, incident);
    }

    // –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
    notify_security_team(incident);
}

void execute_response_playbook(incident_response_t *ir,
                              incident_t *incident) {

    // –ü–æ–∏—Å–∫ –ø–æ–¥—Ö–æ–¥—è—â–µ–≥–æ playbook
    for (guint i = 0; i < ir->response_playbooks->len; i++) {
        response_playbook_t *playbook = g_ptr_array_index(ir->response_playbooks, i);

        if (strcmp(playbook->incident_type, incident->type) == 0) {
            execute_playbook_actions(playbook, incident);
            break;
        }
    }
}
```

## ‚ú® –õ—É—á—à–∏–µ –ø—Ä–∞–∫—Ç–∏–∫–∏

### 1. Defense in Depth

```c
// –ú–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤–∞—è –∑–∞—â–∏—Ç–∞
typedef struct defense_layers {
    input_validation_t *input_layer;
    authentication_t *auth_layer;
    authorization_t *access_layer;
    encryption_t *crypto_layer;
    monitoring_t *audit_layer;
} defense_layers_t;

bool process_secure_request(defense_layers_t *defense,
                           const char *request_data,
                           size_t request_size,
                           const char *client_ip,
                           const char *session_token) {

    // –°–ª–æ–π 1: –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    if (!validate_input(defense->input_layer, request_data, request_size)) {
        log_security_event("Invalid input detected", client_ip);
        return false;
    }

    // –°–ª–æ–π 2: –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è
    if (!authenticate_user(defense->auth_layer, session_token)) {
        log_security_event("Authentication failed", client_ip);
        return false;
    }

    // –°–ª–æ–π 3: –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è
    if (!authorize_action(defense->access_layer, request_data)) {
        log_security_event("Authorization failed", client_ip);
        return false;
    }

    // –°–ª–æ–π 4: –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ)
    char *encrypted_request = encrypt_request(defense->crypto_layer, request_data);
    if (!encrypted_request) {
        log_security_event("Encryption failed", client_ip);
        return false;
    }

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–ø—Ä–æ—Å–∞
    bool result = process_request_securely(encrypted_request);

    // –°–ª–æ–π 5: –ê—É–¥–∏—Ç
    audit_request(defense->audit_layer, request_data, result, client_ip);

    free(encrypted_request);
    return result;
}
```

### 2. Secure Coding Standards

```c
// –ë–µ–∑–æ–ø–∞—Å–Ω—ã–µ –º–∞–∫—Ä–æ—Å—ã
#define SAFE_FREE(ptr) \
    do { \
        if (ptr) { \
            memset(ptr, 0, malloc_usable_size(ptr)); \
            free(ptr); \
            ptr = NULL; \
        } \
    } while(0)

#define SAFE_STRCPY(dest, src, dest_size) \
    do { \
        if (dest && src && dest_size > 0) { \
            size_t copy_len = strnlen(src, dest_size - 1); \
            memcpy(dest, src, copy_len); \
            dest[copy_len] = '\0'; \
        } \
    } while(0)

#define VALIDATE_PTR(ptr) \
    ((ptr) && ((uintptr_t)(ptr) >= 0x1000) && ((uintptr_t)(ptr) < UINTPTR_MAX))

// –ë–µ–∑–æ–ø–∞—Å–Ω—ã–µ –∞—Ä–∏—Ñ–º–µ—Ç–∏—á–µ—Å–∫–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
bool safe_add(size_t a, size_t b, size_t *result) {
    if (a > SIZE_MAX - b) {
        return false; // –ü–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ
    }
    *result = a + b;
    return true;
}

bool safe_mul(size_t a, size_t b, size_t *result) {
    if (a != 0 && b > SIZE_MAX / a) {
        return false; // –ü–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ
    }
    *result = a * b;
    return true;
}
```

### 3. Regular Security Audits

```c
// –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∞—É–¥–∏—Ç
typedef struct security_audit_schedule {
    time_t next_audit_time;
    uint32_t audit_interval_days;
    GPtrArray *audit_checks;
    audit_report_t *last_report;
} security_audit_schedule_t;

void run_scheduled_security_audit(security_audit_schedule_t *schedule) {
    time_t now = time(NULL);

    if (now >= schedule->next_audit_time) {
        audit_report_t *report = perform_comprehensive_audit(schedule->audit_checks);

        if (report->critical_findings > 0) {
            send_security_alert("Critical security findings detected", report);
        }

        // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –æ—Ç—á–µ—Ç–∞
        if (schedule->last_report) {
            free_audit_report(schedule->last_report);
        }
        schedule->last_report = report;

        // –ü–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–ª–µ–¥—É—é—â–µ–≥–æ –∞—É–¥–∏—Ç–∞
        schedule->next_audit_time = now + (schedule->audit_interval_days * 24 * 3600);
    }
}

audit_report_t *perform_comprehensive_audit(GPtrArray *checks) {
    audit_report_t *report = g_new(audit_report_t, 1);
    report->start_time = time(NULL);
    report->findings = g_ptr_array_new();

    for (guint i = 0; i < checks->len; i++) {
        audit_check_t *check = g_ptr_array_index(checks, i);

        audit_finding_t *finding = run_audit_check(check);
        if (finding) {
            g_ptr_array_add(report->findings, finding);

            if (strcmp(finding->severity, "critical") == 0) {
                report->critical_findings++;
            }
        }
    }

    report->end_time = time(NULL);
    report->duration = report->end_time - report->start_time;

    return report;
}
```

---

## üéØ –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å - —ç—Ç–æ –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω—ã–π –ø—Ä–æ—Ü–µ—Å—Å, —Ç—Ä–µ–±—É—é—â–∏–π –∫–æ–º–ø–ª–µ–∫—Å–Ω–æ–≥–æ –ø–æ–¥—Ö–æ–¥–∞ –Ω–∞ –≤—Å–µ—Ö —É—Ä–æ–≤–Ω—è—Ö –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è. –°–ª–µ–¥—É—è –ø—Ä–∏–Ω—Ü–∏–ø–∞–º, –æ–ø–∏—Å–∞–Ω–Ω—ã–º –≤ —ç—Ç–æ–º —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–µ, –≤—ã —Å–º–æ–∂–µ—Ç–µ —Å–æ–∑–¥–∞—Ç—å –Ω–∞–¥–µ–∂–Ω—ã–µ –∏ –∑–∞—â–∏—â–µ–Ω–Ω—ã–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –Ω–∞ –±–∞–∑–µ CellFrame DAP SDK.

**üîê –ü–æ–º–Ω–∏—Ç–µ:** "–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –ø—Ä–æ–¥—É–∫—Ç–æ–º, –∞ –ø—Ä–æ—Ü–µ—Å—Å–æ–º!"

**üìû –ù—É–∂–Ω–∞ –ø–æ–º–æ—â—å?** –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –Ω–∞—à—É [—Å–ª—É–∂–±—É –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏](https://cellframe.net/security) –∏–ª–∏ —Å–æ–æ–±—â–µ—Å—Ç–≤–æ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤.

**üîí –•–æ—Ç–∏—Ç–µ —É–∑–Ω–∞—Ç—å –±–æ–ª—å—à–µ?** –ò–∑—É—á–∏—Ç–µ –Ω–∞—à–∏ [—Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏](https://docs.cellframe.net/security/best-practices)!


